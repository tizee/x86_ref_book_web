(window.webpackJsonp=window.webpackJsonp||[]).push([[225],{579:function(t,e,r){"use strict";r.r(e);var a=r(42),v=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"or"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#or"}},[t._v("#")]),t._v(" OR")]),t._v(" "),r("h2",{attrs:{id:"logical-inclusive-or"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#logical-inclusive-or"}},[t._v("#")]),t._v(" Logical Inclusive OR")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("Opcode")]),t._v(" "),r("th",[t._v("Mnemonic")]),t._v(" "),r("th",[t._v("Description")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("0C ib")]),t._v(" "),r("td",[t._v("OR AL,imm8")]),t._v(" "),r("td",[t._v("AL OR imm8.")])]),t._v(" "),r("tr",[r("td",[t._v("0D iw")]),t._v(" "),r("td",[t._v("OR AX,imm16")]),t._v(" "),r("td",[t._v("AX OR imm16.")])]),t._v(" "),r("tr",[r("td",[t._v("0D id")]),t._v(" "),r("td",[t._v("OR EAX,imm32")]),t._v(" "),r("td",[t._v("EAX OR imm32.")])]),t._v(" "),r("tr",[r("td",[t._v("80 /1 ib")]),t._v(" "),r("td",[t._v("OR r/m8,imm8")]),t._v(" "),r("td",[t._v("r/m8 OR imm8.")])]),t._v(" "),r("tr",[r("td",[t._v("81 /1 iw")]),t._v(" "),r("td",[t._v("OR r/m16,imm16")]),t._v(" "),r("td",[t._v("r/m16 OR imm16.")])]),t._v(" "),r("tr",[r("td",[t._v("81 /1 id")]),t._v(" "),r("td",[t._v("OR r/m32,imm32")]),t._v(" "),r("td",[t._v("r/m32 OR imm32")])]),t._v(" "),r("tr",[r("td",[t._v("83 /1 ib")]),t._v(" "),r("td",[t._v("OR r/m16,imm8")]),t._v(" "),r("td",[t._v("r/m16 OR imm8 (sign-extended).")])]),t._v(" "),r("tr",[r("td",[t._v("83 /1 ib")]),t._v(" "),r("td",[t._v("OR r/m32,imm8")]),t._v(" "),r("td",[t._v("r/m32 OR imm8 (sign-extended).")])]),t._v(" "),r("tr",[r("td",[t._v("08 /r")]),t._v(" "),r("td",[t._v("OR r/m8,r8")]),t._v(" "),r("td",[t._v("r/m8 OR r8.")])]),t._v(" "),r("tr",[r("td",[t._v("09 /r")]),t._v(" "),r("td",[t._v("OR r/m16,r16")]),t._v(" "),r("td",[t._v("r/m16 OR r16.")])]),t._v(" "),r("tr",[r("td",[t._v("09 /r")]),t._v(" "),r("td",[t._v("OR r/m32,r32")]),t._v(" "),r("td",[t._v("r/m32 OR r32.")])]),t._v(" "),r("tr",[r("td",[t._v("0A /r")]),t._v(" "),r("td",[t._v("OR r8,r/m8")]),t._v(" "),r("td",[t._v("r8 OR r/m8.")])]),t._v(" "),r("tr",[r("td",[t._v("0B /r")]),t._v(" "),r("td",[t._v("OR r16,r/m16")]),t._v(" "),r("td",[t._v("r16 OR r/m16.")])]),t._v(" "),r("tr",[r("td",[t._v("0B /r")]),t._v(" "),r("td",[t._v("OR r32,r/m32")]),t._v(" "),r("td",[t._v("r32 OR r/m32.")])])])]),t._v(" "),r("h2",{attrs:{id:"description"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#description"}},[t._v("#")]),t._v(" Description")]),t._v(" "),r("p",[t._v("Performs a bitwise inclusive OR operation between the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result of the OR instruction is set to 0 if both corresponding bits of the first and second operands are 0; otherwise, each bit is set to 1.")]),t._v(" "),r("p",[t._v("This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.")]),t._v(" "),r("h2",{attrs:{id:"operation"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#operation"}},[t._v("#")]),t._v(" Operation")]),t._v(" "),r("div",{staticClass:"language-c line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-c"}},[r("code",[t._v("Destination "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Destination "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" Source"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br")])]),r("h2",{attrs:{id:"flags-affected"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#flags-affected"}},[t._v("#")]),t._v(" Flags affected")]),t._v(" "),r("p",[t._v("The OF and CF flags are cleared; the SF, ZF, and PF flags are set according to the result. The state of the AF flag is undefined.")]),t._v(" "),r("h2",{attrs:{id:"protected-mode-exceptions"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#protected-mode-exceptions"}},[t._v("#")]),t._v(" Protected Mode Exceptions")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[r("a",{attrs:{href:""}})]),t._v(" "),r("th")])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("#GP(0)")]),t._v(" "),r("td",[t._v("If the destination operand points to a non-writable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.")])]),t._v(" "),r("tr",[r("td",[t._v("#GP(0)")]),t._v(" "),r("td",[t._v("If the destination operand points to a non-writable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.")])]),t._v(" "),r("tr",[r("td",[t._v("#SS(0)")]),t._v(" "),r("td",[t._v("If a memory operand effective address is outside the SS segment limit.")])]),t._v(" "),r("tr",[r("td",[t._v("#PF(fault-code)")]),t._v(" "),r("td",[t._v("If a page fault occurs.")])])])]),t._v(" "),r("h2",{attrs:{id:"real-address-mode-exceptions"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#real-address-mode-exceptions"}},[t._v("#")]),t._v(" Real-Address Mode Exceptions")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[r("a",{attrs:{href:""}})]),t._v(" "),r("th")])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("#GP")]),t._v(" "),r("td",[t._v("If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.")])]),t._v(" "),r("tr",[r("td",[t._v("#GP")]),t._v(" "),r("td",[t._v("If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.")])])])]),t._v(" "),r("h2",{attrs:{id:"virtual-8086-mode-exceptions"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#virtual-8086-mode-exceptions"}},[t._v("#")]),t._v(" Virtual-8086 Mode Exceptions")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[r("a",{attrs:{href:""}})]),t._v(" "),r("th")])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("#GP(0)")]),t._v(" "),r("td",[t._v("If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.")])]),t._v(" "),r("tr",[r("td",[t._v("#GP(0)")]),t._v(" "),r("td",[t._v("If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.")])]),t._v(" "),r("tr",[r("td",[t._v("#SS(0)")]),t._v(" "),r("td",[t._v("If a memory operand effective address is outside the SS segment limit.")])]),t._v(" "),r("tr",[r("td",[t._v("#PF(fault-code)")]),t._v(" "),r("td",[t._v("If a page fault occurs.")])])])]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("Instruction")]),t._v(" "),r("th",[t._v("Latency")]),t._v(" "),r("th",[t._v("Throughput")]),t._v(" "),r("th",[t._v("Execution Unit")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("CPUID")]),t._v(" "),r("td",[t._v("0F3n/0F2n")]),t._v(" "),r("td",[t._v("0F3n/0F2n")]),t._v(" "),r("td",[t._v("0F2n")])]),t._v(" "),r("tr",[r("td",[t._v("OR")]),t._v(" "),r("td",[t._v("1/0.5")]),t._v(" "),r("td",[t._v("0.5/0.5")]),t._v(" "),r("td",[t._v("ALU")])])])])])}),[],!1,null,null,null);e.default=v.exports}}]);