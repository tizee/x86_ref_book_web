(window.webpackJsonp=window.webpackJsonp||[]).push([[107],{460:function(t,e,a){"use strict";a.r(e);var n=a(42),r=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"fisttp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fisttp"}},[t._v("#")]),t._v(" FISTTP")]),t._v(" "),a("h2",{attrs:{id:"store-integer-with-truncation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#store-integer-with-truncation"}},[t._v("#")]),t._v(" Store Integer with Truncation")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Opcode")]),t._v(" "),a("th",[t._v("Mnemonic")]),t._v(" "),a("th",[t._v("Description")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("DF /1")]),t._v(" "),a("td",[t._v("FISTTP m16int")]),t._v(" "),a("td",[t._v("Store ST as a signed integer (truncate) in m16int and pop ST.")])]),t._v(" "),a("tr",[a("td",[t._v("DB /1")]),t._v(" "),a("td",[t._v("FISTTP m32int")]),t._v(" "),a("td",[t._v("Store ST as a signed integer (truncate) in m32int and pop ST.")])]),t._v(" "),a("tr",[a("td",[t._v("DD /1")]),t._v(" "),a("td",[t._v("FISTTP m64int")]),t._v(" "),a("td",[t._v("Store ST as a signed integer (truncate) in m64int and pop ST.")])])])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Description")]),t._v(" "),a("th",[t._v("ST(0)")]),t._v(" "),a("th",[t._v("Destination")])])]),t._v(" "),a("tbody",[a("tr",[a("td"),t._v(" "),a("td"),t._v(" "),a("td")])])]),t._v(" "),a("p",[t._v("FISTTP converts the value in ST into a signed integer using truncation (chop) as rounding mode, transfers the result to the destination, and pop ST. FISTTP accepts word, short integer, and long integer destinations.\nThe following table shows the results obtained when storing various classes of numbers in integer format.")]),t._v(" "),a("p",[t._v("FISTTP Results\nST(0)Destination\n-inf or Value Too Large for DestinationFormat *\nF = -1-I")]),t._v(" "),a("ul",[a("li",[t._v("1 < F < +10\nF = +1+I\n+inf or Value Too Large for Destination Format*\nNaN*")])]),t._v(" "),a("p",[t._v("F Means finite floating-point value.\nI Means integer.")]),t._v(" "),a("ul",[a("li",[t._v("Indicates floating-point invalid-operation (#IA) exception.")])]),t._v(" "),a("p",[t._v("|-inf or Value Too Large for Destination|Format "),a("em",[t._v("|F = -1|-I|- 1 < F < +1|0|F = +1|+I|+inf or Value Too Large for Destination Format|")]),t._v("|NaN|"),a("em",[t._v("|F Means finite floating-point value.|I Means integer.|")]),t._v(" Indicates floating-point invalid-operation (#IA) exception.|\n|\n|-inf or Value Too Large for Destination|Format "),a("em",[t._v("|\n|F = -1|-I|\n|- 1 < F < +1|0|\n|F = +1|+I|\n|+inf or Value Too Large for Destination Format|")]),t._v("|\n|NaN|"),a("em",[t._v("|\n|F Means finite floating-point value.|\n|I Means integer.|\n|")]),t._v(" Indicates floating-point invalid-operation (#IA) exception.|")]),t._v(" "),a("h2",{attrs:{id:"operation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#operation"}},[t._v("#")]),t._v(" Operation")]),t._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[t._v("Destination "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" ST"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nST "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Pop")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("h2",{attrs:{id:"flags-affected"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flags-affected"}},[t._v("#")]),t._v(" Flags affected")]),t._v(" "),a("p",[t._v("C1 is cleared; C0, C2, C3 undefined.")]),t._v(" "),a("h2",{attrs:{id:"numeric-exceptions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#numeric-exceptions"}},[t._v("#")]),t._v(" Numeric Exceptions")]),t._v(" "),a("p",[t._v("Invalid, Stack Invalid (stack underflow), Precision.")]),t._v(" "),a("h2",{attrs:{id:"protected-mode-exceptions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#protected-mode-exceptions"}},[t._v("#")]),t._v(" Protected Mode Exceptions")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[a("a",{attrs:{href:""}})]),t._v(" "),a("th")])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("#GP(0)")]),t._v(" "),a("td",[t._v("If the destination is in a nonwritable segment. For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments.")])]),t._v(" "),a("tr",[a("td",[t._v("#GP(0)")]),t._v(" "),a("td",[t._v("If the destination is in a nonwritable segment. For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments.")])]),t._v(" "),a("tr",[a("td",[t._v("#SS(0)")]),t._v(" "),a("td",[t._v("For an illegal address in the SS segment.")])]),t._v(" "),a("tr",[a("td",[t._v("#PF(fault-code)")]),t._v(" "),a("td",[t._v("For a page fault.")])]),t._v(" "),a("tr",[a("td",[t._v("#AC(0)")]),t._v(" "),a("td",[t._v("If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.")])]),t._v(" "),a("tr",[a("td",[t._v("#NM")]),t._v(" "),a("td",[t._v("If CR0.EM = 1. If TS bit in CR0 is set.")])])])]),t._v(" "),a("h2",{attrs:{id:"real-address-mode-exceptions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#real-address-mode-exceptions"}},[t._v("#")]),t._v(" Real-Address Mode Exceptions")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[a("a",{attrs:{href:""}})]),t._v(" "),a("th")])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("#GP(0)")]),t._v(" "),a("td",[t._v("If any part of the operand would lie outside of the effective address space from 0 to 0FFFFH.")])]),t._v(" "),a("tr",[a("td",[t._v("#GP(0)")]),t._v(" "),a("td",[t._v("If any part of the operand would lie outside of the effective address space from 0 to 0FFFFH.")])]),t._v(" "),a("tr",[a("td",[t._v("#NM")]),t._v(" "),a("td",[t._v("If CR0.EM = 1. If TS bit in CR0 is set.")])])])]),t._v(" "),a("h2",{attrs:{id:"virtual-8086-mode-exceptions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#virtual-8086-mode-exceptions"}},[t._v("#")]),t._v(" Virtual-8086 Mode Exceptions")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[a("a",{attrs:{href:""}})]),t._v(" "),a("th")])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("#GP(0)")]),t._v(" "),a("td",[t._v("If any part of the operand would lie outside of the effective address space from 0 to 0FFFFH.")])]),t._v(" "),a("tr",[a("td",[t._v("#GP(0)")]),t._v(" "),a("td",[t._v("If any part of the operand would lie outside of the effective address space from 0 to 0FFFFH.")])]),t._v(" "),a("tr",[a("td",[t._v("#NM")]),t._v(" "),a("td",[t._v("If CR0.EM = 1. If TS bit in CR0 is set.")])]),t._v(" "),a("tr",[a("td",[t._v("#UD")]),t._v(" "),a("td",[t._v("If CPUID.SSE3(ECX bit 0) = 0.")])]),t._v(" "),a("tr",[a("td",[t._v("#PF(fault-code)")]),t._v(" "),a("td",[t._v("For a page fault.")])])])])])}),[],!1,null,null,null);e.default=r.exports}}]);