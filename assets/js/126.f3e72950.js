(window.webpackJsonp=window.webpackJsonp||[]).push([[126],{480:function(t,e,s){"use strict";s.r(e);var r=s(42),a=Object(r.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"fstcw-fnstcw"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fstcw-fnstcw"}},[t._v("#")]),t._v(" FSTCW/FNSTCW")]),t._v(" "),s("h2",{attrs:{id:"store-x87-fpu-control-word"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#store-x87-fpu-control-word"}},[t._v("#")]),t._v(" Store x87 FPU Control Word")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("Opcode")]),t._v(" "),s("th",[t._v("Mnemonic")]),t._v(" "),s("th",[t._v("Description")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("9B D9 /7")]),t._v(" "),s("td",[t._v("FSTCW m2byte")]),t._v(" "),s("td",[t._v("Store FPU control word to m2byte after checking for pending unmasked floating-point exceptions.")])]),t._v(" "),s("tr",[s("td",[t._v("D9 /7")]),t._v(" "),s("td",[t._v("FNSTCW m2byte")]),t._v(" "),s("td",[t._v("Store FPU control word to m2byte without checking for pending unmasked floating-point exceptions. See IA-32 Architecture Compatibility section below.")])])])]),t._v(" "),s("h2",{attrs:{id:"description"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#description"}},[t._v("#")]),t._v(" Description")]),t._v(" "),s("p",[t._v("Stores the current value of the FPU control word at the specified destination in memory. The FSTCW instruction checks for and handles pending unmasked floating-point exceptions before storing the control word; the FNSTCW instruction does not.")]),t._v(" "),s("p",[t._v("The assembler issues two instructions for the FSTCW instruction (an FWAIT instruction followed by an FNSTCW instruction), and the processor executes each of these instructions in separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.")]),t._v(" "),s("h2",{attrs:{id:"operation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#operation"}},[t._v("#")]),t._v(" Operation")]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[t._v("Destination "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" FPUControlWord"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("h2",{attrs:{id:"fpu-flags-affected"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fpu-flags-affected"}},[t._v("#")]),t._v(" FPU flags affected")]),t._v(" "),s("p",[t._v("The C0, C1, C2, and C3 flags are undefined.")]),t._v(" "),s("h2",{attrs:{id:"ia-32-architecture-compatibility"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ia-32-architecture-compatibility"}},[t._v("#")]),t._v(" IA-32 Architecture Compatibility")]),t._v(" "),s("p",[t._v('When operating a Pentium or Intel486 processor in MS-DOS compatibility mode, it is possible (under unusual circumstances) for an FNSTCW instruction to be interrupted prior to being executed to handle a pending FPU exception. See the section titled "No-Wait FPU Instructions Can Get FPU Interrupt in Window" in Appendix D of the IA-32 Intel Architecture Software Developer\'s Manual, Volume 1, for a description of these circumstances. An FNSTCW instruction cannot be interrupted in this way on a Pentium 4, Intel Xeon, or P6 family processor.')]),t._v(" "),s("h2",{attrs:{id:"floating-point-exceptions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#floating-point-exceptions"}},[t._v("#")]),t._v(" Floating-Point Exceptions")]),t._v(" "),s("p",[t._v("None.")]),t._v(" "),s("h2",{attrs:{id:"protected-mode-exceptions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#protected-mode-exceptions"}},[t._v("#")]),t._v(" Protected Mode Exceptions")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[s("a",{attrs:{href:""}})]),t._v(" "),s("th")])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("#GP(0)")]),t._v(" "),s("td",[t._v("If the destination is located in a non-writable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.")])]),t._v(" "),s("tr",[s("td",[t._v("#GP(0)")]),t._v(" "),s("td",[t._v("If the destination is located in a non-writable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.")])]),t._v(" "),s("tr",[s("td",[t._v("#SS(0)")]),t._v(" "),s("td",[t._v("If a memory operand effective address is outside the SS segment limit.")])]),t._v(" "),s("tr",[s("td",[t._v("#NM")]),t._v(" "),s("td",[t._v("EM or TS in CR0 is set.")])]),t._v(" "),s("tr",[s("td",[t._v("#PF(fault-code)")]),t._v(" "),s("td",[t._v("If a page fault occurs.")])])])]),t._v(" "),s("h2",{attrs:{id:"real-address-mode-exceptions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#real-address-mode-exceptions"}},[t._v("#")]),t._v(" Real-Address Mode Exceptions")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[s("a",{attrs:{href:""}})]),t._v(" "),s("th")])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("#GP")]),t._v(" "),s("td",[t._v("If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.")])]),t._v(" "),s("tr",[s("td",[t._v("#GP")]),t._v(" "),s("td",[t._v("If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.")])]),t._v(" "),s("tr",[s("td",[t._v("#SS")]),t._v(" "),s("td",[t._v("If a memory operand effective address is outside the SS segment limit.")])])])]),t._v(" "),s("h2",{attrs:{id:"virtual-8086-mode-exceptions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#virtual-8086-mode-exceptions"}},[t._v("#")]),t._v(" Virtual-8086 Mode Exceptions")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[s("a",{attrs:{href:""}})]),t._v(" "),s("th")])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("#GP(0)")]),t._v(" "),s("td",[t._v("If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.")])]),t._v(" "),s("tr",[s("td",[t._v("#GP(0)")]),t._v(" "),s("td",[t._v("If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.")])]),t._v(" "),s("tr",[s("td",[t._v("#SS(0)")]),t._v(" "),s("td",[t._v("If a memory operand effective address is outside the SS segment limit.")])]),t._v(" "),s("tr",[s("td",[t._v("#NM")]),t._v(" "),s("td",[t._v("EM or TS in CR0 is set.")])]),t._v(" "),s("tr",[s("td",[t._v("#PF(fault-code)")]),t._v(" "),s("td",[t._v("If a page fault occurs.")])])])])])}),[],!1,null,null,null);e.default=a.exports}}]);