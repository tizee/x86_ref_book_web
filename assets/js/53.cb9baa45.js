(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{409:function(e,t,s){"use strict";s.r(t);var n=s(42),r=Object(n.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"cpuid"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cpuid"}},[e._v("#")]),e._v(" CPUID")]),e._v(" "),s("h2",{attrs:{id:"cpu-identification"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cpu-identification"}},[e._v("#")]),e._v(" CPU Identification")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("Opcode")]),e._v(" "),s("th",[e._v("Mnemonic")]),e._v(" "),s("th",[e._v("Description")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("0F A2")]),e._v(" "),s("td",[e._v("CPUID")]),e._v(" "),s("td",[e._v("Returns processor identification and feature information to the EAX, EBX, ECX, and EDX registers, according to the input value entered initially in the EAX register.")])])])]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("Description")]),e._v(" "),s("th",[e._v("Initial EAX Value")]),e._v(" "),s("th",[e._v("Register")]),e._v(" "),s("th",[e._v("Information Provided about the Processor")]),e._v(" "),s("th",[e._v("Initial EAX Value")]),e._v(" "),s("th",[e._v("Register")]),e._v(" "),s("th",[e._v("Information Provided about the Processor")]),e._v(" "),s("th",[e._v("IA-32 Processors")]),e._v(" "),s("th",[e._v("Basic Information")]),e._v(" "),s("th",[e._v("Extended Function Information")]),e._v(" "),s("th",[e._v("Bit #")]),e._v(" "),s("th",[e._v("Information")]),e._v(" "),s("th",[e._v("Type")]),e._v(" "),s("th",[e._v("Encoding")]),e._v(" "),s("th",[e._v("Bit #")]),e._v(" "),s("th",[e._v("Mnemonic")]),e._v(" "),s("th",[e._v("Description")]),e._v(" "),s("th",[e._v("Bit #")]),e._v(" "),s("th",[e._v("Mnemonic")]),e._v(" "),s("th",[e._v("Description")]),e._v(" "),s("th",[e._v("Descriptor")]),e._v(" "),s("th",[e._v("Value Cache or TLB Description")]),e._v(" "),s("th",[e._v("EAX Input Value")]),e._v(" "),s("th",[e._v("Return Values")]),e._v(" "),s("th",[e._v("ASCII Equivalent")]),e._v(" "),s("th",[e._v("Brand Index")]),e._v(" "),s("th",[e._v("Brand String")])])]),e._v(" "),s("tbody",[s("tr",[s("td"),e._v(" "),s("td"),e._v(" "),s("td"),e._v(" "),s("td"),e._v(" "),s("td"),e._v(" "),s("td"),e._v(" "),s("td"),e._v(" "),s("td"),e._v(" "),s("td"),e._v(" "),s("td"),e._v(" "),s("td"),e._v(" "),s("td"),e._v(" "),s("td"),e._v(" "),s("td"),e._v(" "),s("td"),e._v(" "),s("td"),e._v(" "),s("td"),e._v(" "),s("td"),e._v(" "),s("td"),e._v(" "),s("td"),e._v(" "),s("td"),e._v(" "),s("td"),e._v(" "),s("td"),e._v(" "),s("td"),e._v(" "),s("td"),e._v(" "),s("td"),e._v(" "),s("td")])])]),e._v(" "),s("p",[e._v("The ID flag (bit 21) in the EFLAGS register indicates support for the CPUID instruction. If a software procedure can set and clear this flag, the processor executing the procedure supports the CPUID instruction.\nCPUID returns processor identification and feature information in the EAX, EBX, ECX, and EDX registers. The instruction's output is dependent on the contents of the EAX register upon execution. For example, the following pseudocode loads EAX with 00H and causes CPUID to return a Maximum Return Value and the Vendor Identification String in the appropriate registers: MOV EAX, 00H CPUID. The following shows information returned, depending on the initial value loaded into the EAX register. The second table shows the maximum CPUID input value recognized for each family of IA- 32 processors on which CPUID is implemented.\nTwo types of information are returned: basic and extended function information. If a higher value entered than is valid for a particular processor, the information for the highest useful basic information value is returned. For example, if an input value of 5 is entered in EAX for a Pentium 4 processor, the information for an input value of 2 is returned. The exception to this rule is the input values that return extended function information. For a Pentium 4 processor, entering an input value of 80000005H or above returns the information for an input value of 2.\nCPUID can be executed at any privilege level to serialize instruction execution. Serializing instruction execution guarantees that any modifications to flags, registers, and memory for previous instructions are completed before the next instruction is fetched and executed.\nSee also: \"Serializing Instructions\" in Chapter 7 of the IA-32 Intel Architecture Software Developer's Manual, Volume 3 AP-485, Intel Processor Identification and the CPUID Instruction (Order Number 241618)\nINPUT EAX = 0: Returns CPUID's Highest Value for Basic Processor Information and the Vendor Identification StringWhen CPUID executes with EAX set to 0, the processor returns the highest value the CPUID recognizes for returning basic processor information. The value is returned in the EAX register (see second table) and is processor specific.\nInformation Returned by CPUID Instruction")]),e._v(" "),s("p",[e._v('Basic CPUID Information\nInitial EAX ValueRegisterInformation Provided about the Processor\n0HEAXMaximum Input Value for Basic CPUID Information (see second table)\n-EBX"Genu"\n-ECX"ntel"\n-EDX"ineI"\n01HEAXVersion Information: Type, Family, Model, and Stepping ID\n-EBXBits 7-0: Brand Index\n--Bits 15-8: CLFLUSH line size (Value . 8 = cache line size in bytes)\n--Bits 23-16: Number of logical processors per physical processor; two for the Pentium 4 processor supporting Hyper-Threading Technology\n--Bits 31-24: Local APIC ID\n-ECXExtended Feature Information (see fourth table)\n-EDXFeature Information (see fifth table)\n02HEAXCache and TLB Information (see sixth table)\n-EBXCache and TLB Information\n-ECXCache and TLB Information\n-EDXCache and TLB Information\n03HEAXReserved.\n-EBXReserved.\n-ECXBits 00-31 of 96 bit processor serial number. (Available in Pentium III processor only; otherwise, the value in this register is reserved.)\n-EDXBits 32-63 of 96 bit processor serial number. (Available in Pentium III processor only; otherwise, the value in this register is reserved.)\n--NOTE: Processor serial number (PSN) is not supported in the Pentium 4 processor or later. On all models, use the PSN flag (returned using CPUID) to check for PSN support before accessing the feature. See AP-485, Intel Processor Identification and the CPUID Instruction (Order Number 241618) for more information on PSN.\n04HEAXBits 4-0: Cache Type**\n--Bits 7-5: Cache Level (starts at 1)\n--Bits 8: Self Initializing cache level (does not need SW initialization)\n--Bits 9: Fully Associative cache\n--Bits 13-10: Reserved\n--Bits 25-14: Number of threads sharing this cache*\n--Bits 31-26: Number of processor cores on this die (Multicore)*\n-EBXBits 11-00: L = System Coherency Line Size*\n--Bits 21-12: P = Physical Line partitions*\n--Bits 31-22: W = Ways of associativity*\n-ECXBits 31-00: S = Number of Sets*\n-EDXReserved = 0\n--0 = Null - No more caches\n--1 = Data Cache\n--2 = Instruction Cache\n--3 = Unified Cache\n--4-31 = Reserved\n--NOTE: CPUID leaves > 3 < 80000000 are only visible when IA32_CR_MISC_ENABLES.BOOT_NT4 (bit 22) is clear (Default)\n5HEAXBits 15-00: Smallest monitor-line size in bytes (default is processor\'s monitor granularity)\n--Bits 31-16: Reserved = 0\n-EBXBits 15-00: Largest monitor-line size in bytes (default is processor\'s monitor granularity)\n--Bits 31-16: Reserved = 0\n-ECXReserved = 0\n-EDXReserved = 0')]),e._v(" "),s("p",[e._v("*Add one to the value in the register file to get the number. For example, the number of processor cores is EAX[31:26]+1.\n** Cache Types fields")]),e._v(" "),s("p",[e._v("Extended Function CPUID Information\nInitial EAX ValueRegisterInformation Provided about the Processor\n80000000HEAXMaximum Input Value for Extended Function CPUID Information (see second table).\n-EBXReserved\n-ECXReserved\n-EDXReserved\n80000001HEAXExtended Processor Signature and Extended Feature Bits. (Currently reserved)\n-EBXReserved\n-ECXReserved\n-EDXReserved\n80000002HEAXProcessor Brand String\n-EBXProcessor Brand String Continued\n-ECXProcessor Brand String Continued\n-EDXProcessor Brand String Continued\n80000003HEAXProcessor Brand String Continued\n-EBXProcessor Brand String Continued\n-ECXProcessor Brand String Continued\n-EDXProcessor Brand String Continued\n80000004HEAXProcessor Brand String Continued\n-EBXProcessor Brand String Continued\n-ECXProcessor Brand String Continued\n-EDXProcessor Brand String Continued\n80000005HEAXReserved = 0\n-EBXReserved = 0\n-ECXReserved = 0\n-EDXReserved = 0\n80000006HEAXReserved = 0\n-EBXReserved = 0\n-ECXBits 0-7: Cache Line Size\n--Bits 15-12: L2 Associativity\n--Bits 31-16: Cache size in 1K units\n-EDXReserved = 0\n-80000007H EAXReserved = 0\n-EBXReserved = 0\n-ECXReserved = 0\n-EDXReserved = 0\n80000008HEAXReserved = 0\n-EBXReserved = 0\n-ECXReserved = 0\n-EDXReserved = 0")]),e._v(" "),s("p",[e._v('A vendor identification string is also returned in EBX, EDX, and ECX. For Intel processors, the string is "GenuineIntel" and is expressed: EBX = 756e6547h (* "Genu", with G in the low nibble of BL '),s("em",[e._v(") EDX = 49656e69h (")]),e._v(' "ineI", with i in the low nibble of DL '),s("em",[e._v(") ECX = 6c65746eh (")]),e._v(' "ntel", with n in the low nibble of CL *)\nINPUT EAX = 80000000H: Returns CPUID\'s Highest Value for Extended Processor InformationWhen CPUID executes with EAX set to 0, the processor returns the highest value the processor recognizes for returning extended processor information. The value is returned in the EAX register (see second table) and is processor specific.')]),e._v(" "),s("p",[e._v("Highest CPUID Source Operand for IA-32 Processors\nIA-32 ProcessorsBasic InformationExtended Function Information\nEarlier Intel486 ProcessorsCPUID Not ImplementedCPUID Not Implemented\nLater Intel486 Processors and Pentium Processors01HNot Implemented\nPentium Pro and Pentium II Processors, Intel�������® Celeron��¢â���ž��¢ Processors02HNot Implemented\nPentium III Processors03HNot Implemented\nPentium 4 Processors02H80000004H\nIntel Xeon Processors02H80000004H\nPentium M Processor02H80000004H\nPentium 4 Processor supporting Hyper-Threading Technology05H80000008H")]),e._v(" "),s("p",[e._v("Returns Microcode Update Signature For processors that support the microcode update facility, the IA32_BIOS_SIGN_ID MSR is loaded with the update signature whenever CPUID executes. The signature is returned in the upper DWORD. For details, see Chapter 9 in the IA-32 Intel Architecture Software Developer's Manual, Volume 3.\nINPUT EAX = 1: Returns Model, Family, Stepping InformationWhen CPUID executes with EAX set to 1, version information is returned in EAX. For example: model, family, and processor type for the first processor in the Intel Pentium 4 family is returned as follows:")]),e._v(" "),s("p",[e._v("Model - 0000B\nFamily - 1111B\nProcessor Type - 00B")]),e._v(" "),s("p",[e._v("See third table for available processor type values. Stepping IDs are provided as needed.")]),e._v(" "),s("p",[e._v("Version Information Returned by CPUID in EAX\nBit #Information\n0-3Stepping ID\n4-7Model\n8-11Family ID\n12-13Processor Type\n14-15Reserved\n16-19Extended Model ID\n20-27Extended Family ID\n28-31Reserved")]),e._v(" "),s("p",[e._v("Processor Type Field\nTypeEncoding\nOriginal OEM Processor00B\nIntel OverDrive�������® Processor01B\nDual processor (not applicable to Intel486 processors)10B\nIntel reserved11B")]),e._v(" "),s("p",[e._v("NOTE See AP-485, Intel Processor Identification and the CPUID Instruction (Order Number 241618) and Chapter 14 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for information on identifying earlier IA-32 processors.")]),e._v(" "),s("p",[e._v("The Extended Family ID and Extended Model ID need be examined only if the Family ID reaches 0FH. Always display processor information as a combination of family, model, and stepping.\nIntegrate the ID fields into a display as: Displayed family = ((Extended Family ID(4-bits) << 4)) (8-bits) + Family ID (4-bits zero extended to 8-bits).\nCompute the displayed model from the Model ID and the Extended Model ID as: Displayed Model = ((Extended Model ID (4-bits) << 4))(8-bits) + Model (4-bits zero extended to 8-bits)\nINPUT EAX = 1: Returns Additional Information in EBXWhen CPUID executes with EAX set to 1, additional information is returned to the EBX register: - Brand index (low byte of EBX) - this number provides an entry into a brand string table that contains brand strings for IA-32 processors. More information about this field is provided later in this section.")]),e._v(" "),s("p",[e._v("CLFLUSH instruction cache line size (second byte of EBX)\nthis number indicates the size of the cache line flushed with CLFLUSH instruction in 8-byte increments. This field was introduced in the Pentium 4 processor.\nLocal APIC ID (high byte of EBX)\nthis number is the 8-bit ID that is assigned to the local APIC on the processor during power up. This field was introduced in the Pentium 4 processor.")]),e._v(" "),s("p",[e._v("INPUT EAX = 1: Returns Feature Information in ECX and EDXWhen CPUID executes with EAX set to 1, feature information is returned in ECX and EDX.")]),e._v(" "),s("p",[e._v("Table four shows encodings for ECX.\nTable five shows encodings for EDX.")]),e._v(" "),s("p",[e._v("For all feature flags, a 1 indicates that the feature is supported. Use Intel to properly interpret feature flags.\nNOTE Software must confirm that a processor feature is present using feature flags returned by CPUID prior to using the feature. Software should not depend on future offerings retaining all features.")]),e._v(" "),s("p",[e._v("Extended Feature Information Returned in the ECX Register\nBit #MnemonicDescription\n0SSE3Streaming SIMD Extensions 3 (SSE3). A value of 1 indicates the processor supports this technology.\n1-2-Reserved\n3MONITORMONITOR/MWAIT. A value of 1 indicates the processor supports this feature.\n4DS-CPLCPL Qualified Debug Store. A value of 1 indicates the processor supports the extensions to the Debug Store feature to allow for branch message storage qualified by CPL.\n5-6-Reserved\n7ESTEnhanced Intel SpeedStep�������® technology. A value of 1 indicates that the processor supports this technology.\n8TM2Thermal Monitor 2. A value of 1 indicates whether the processor supports this technology.\n9-Reserved\n10CNXT-IDL1 Context ID. A value of 1 indicates the L1 data cache mode can be set to either adaptive mode or shared mode. A value of 0 indicates this feature is not supported. See definition of the IA32_MISC_ENABLE MSR Bit 24 (L1 Data Cache Context Mode) for details.\n11-31-Reserved")]),e._v(" "),s("p",[e._v("Feature Information Returned in the EDX Register\nBit #MnemonicDescription\n0FPUFloating Point Unit On-Chip. The processor contains an x87 FPU.\n1VMEVirtual 8086 Mode Enhancements. Virtual 8086 mode enhancements, including CR4.VME for controlling the feature, CR4.PVI for protected mode virtual interrupts, software interrupt indirection, expansion of the TSS with the software indirection bitmap, and EFLAGS.VIF and EFLAGS.VIP flags.\n2DEDebugging Extensions. Support for I/O breakpoints, including CR4.DE for controlling the feature, and optional trapping of accesses to DR4 and DR5.\n3PSEPage Size Extension. Large pages of size 4 MByte are supported, including CR4.PSE for controlling the feature, the defined dirty bit in PDE (Page Directory Entries), optional reserved bit trapping in CR3, PDEs, and PTEs.\n4TSCTime Stamp Counter. The RDTSC instruction is supported, including CR4.TSD for controlling privilege.\n5MSRModel Specific Registers RDMSR and WRMSR Instructions. The RDMSR and WRMSR instructions are supported. Some of the MSRs are implementation dependent.\n6PAEPhysical Address Extension. Physical addresses greater than 32 bits are supported: extended page table entry formats, an extra level in the page translation tables is defined, 2-MByte pages are supported instead of 4 Mbyte pages if PAE bit is 1. The actual number of address bits beyond 32 is not defined, and is implementation specific.\n7MCEMachine Check Exception. Exception 18 is defined for Machine Checks, including CR4.MCE for controlling the feature. This feature does not define the model-specific implementations of machine-check error logging, reporting, and processor shutdowns. Machine Check exception handlers may have to depend on processor version to do model specific processing of the exception, or test for the presence of the Machine Check feature.\n8CX8CMPXCHG8B Instruction. The compare-and-exchange 8 bytes (64 bits) instruction is supported (implicitly locked and atomic).\n9APICAPIC On-Chip. The processor contains an Advanced Programmable Interrupt Controller (APIC), responding to memory mapped commands in the physical address range FFFE0000H to FFFE0FFFH (by default - some processors permit the APIC to be relocated).\n10-Reserved\n11SEPSYSENTER and SYSEXIT Instructions. The SYSENTER and SYSEXIT and associated MSRs are supported. 12 MTRR Memory Type Range Registers. MTRRs are supported. The MTRRcap MSR contains feature bits that describe what memory types are supported, how many variable MTRRs are supported, and whether fixed MTRRs are supported.\n13PGEPTE Global Bit. The global bit in page directory entries (PDEs) and page table entries (PTEs) is supported, indicating TLB entries that are common to different processes and need not be flushed. The CR4.PGE bit controls this feature.\n14MCAMachine Check Architecture. The Machine Check Architecture, which provides a compatible mechanism for error reporting in P6 family, Pentium 4, Intel Xeon processors, and future processors, is supported. The MCG_CAP MSR contains feature bits describing how many banks of error reporting MSRs are supported.\n15CMOVConditional Move Instructions. The conditional move instruction CMOV is supported. In addition, if x87 FPU is present as indicated by the CPUID.FPU feature bit, then the FCOMI and FCMOV instructions are supported\n16PATPage Attribute Table. Page Attribute Table is supported. This feature augments the Memory Type Range Registers (MTRRs), allowing an operating system to specify attributes of memory on a 4K granularity through a linear address.\n17PSE-3636-Bit Page Size Extension. Extended 4-MByte pages that are capable of addressing physical memory beyond 4 GBytes are supported. This feature indicates that the upper four bits of the physical address of the 4-MByte page is encoded by bits 13-16 of the page directory entry.\n18PSNProcessor Serial Number. The processor supports the 96-bit processor identification number feature and the feature is enabled.\n19CLFSHCLFLUSH Instruction. CLFLUSH Instruction is supported. 20 Reserved Reserved\n21DSDebug Store. The processor supports the ability to write debug information into a memory resident buffer. This feature is used by the branch trace store (BTS) and precise event-based sampling (PEBS) facilities (see Chapter 15, Debugging and Performance Monitoring, in the IA-32 Intel Architecture Software Developer's Manual, Volume 3).\n22ACPIThermal Monitor and Software Controlled Clock Facilities. The processor implements internal MSRs that allow processor temperature to be monitored and processor performance to be modulated in predefined duty cycles under software control.\n23MMXIntel MMX Technology. The processor supports the Intel MMX technology.\n24FXSRFXSAVE and FXRSTOR Instructions. The FXSAVE and FXRSTOR instructions are supported for fast save and restore of the floating point context. Presence of this bit also indicates that CR4.OSFXSR is available for an operating system to indicate that it supports the FXSAVE and FXRSTOR instructions.\n25SSESSE. The processor supports the SSE extensions.\n26SSE2SSE2. The processor supports the SSE2 extensions.\n27SSSelf Snoop. The processor supports the management of conflicting memory types by performing a snoop of its own cache structure for transactions issued to the bus.\n28HTTHyper-Threading Technology. The processor supports Hyper-Threading Technology.\n29TMThermal Monitor. The processor implements the thermal monitor automatic thermal control circuitry (TCC).\n30-Reserved\n31PBEPending Break Enable. The processor supports the use of the FERR#/PBE# pin when the processor is in the stop-clock state (STPCLK# is asserted) to signal the processor that an interrupt is pending and that the processor should return to normal operation to handle the interrupt. Bit 10 (PBE enable) in the IA32_MISC_ENABLE MSR enables this capability.")]),e._v(" "),s("p",[e._v("INPUT EAX = 2: Cache and TLB Information Returned in EAX, EBX, ECX, EDXWhen CPUID executes with EAX set to 2, the processor returns information about the processor's internal caches and TLBs in the EAX, EBX, ECX, and EDX registers.\nThe encoding is as follows: - The least-significant byte in register EAX (register AL) indicates the number of times the CPUID instruction must be executed with an input value of 2 to get a complete description of the processor's caches and TLBs. The first member of the family of Pentium 4 processors will return a 1.")]),e._v(" "),s("p",[e._v("The most significant bit (bit 31) of each register indicates whether the register contains valid information (set to 0) or is reserved (set to 1).\nIf a register contains valid information, the information is contained in 1 byte descriptors.")]),e._v(" "),s("p",[e._v("Table six shows the encoding of these descriptors. Note that the order of descriptors in the EAX, EBX, ECX, and EDX registers is not defined; that is, specific bytes are not designated to contain descriptors for specific cache or TLB types. The descriptors may appear in any order.")]),e._v(" "),s("p",[e._v("Encoding of Cache and TLB Descriptors\nDescriptorValue Cache or TLB Description\n00HNull descriptor\n01HInstruction TLB: 4 KByte Pages, 4-way set associative, 32 entries\n02HInstruction TLB: 4 MByte Pages, 4-way set associative, 2 entries\n03HData TLB: 4KByte Pages, 4-way set associative, 64 entries\n04HData TLB: 4MByte Pages, 4-way set associative, 8 entries\n06H1st-level instruction cache: 8 KBytes, 4-way set associative, 32 byte line size\n08H1st-level instruction cache: 16 KBytes, 4-way set associative, 32 byte line size\n0AH1st-level data cache: 8 KBytes, 2-way set associative, 32 byte line size\n0CH1st-level data cache: 16 KBytes, 4-way set associative, 32 byte line size\n22H3rd-level cache: 512 KBytes, 4-way set associative, 64 byte line size, 2 lines per sector\n23H3rd-level cache: 1 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector\n25H3rd-level cache: 2 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector\n29H3rd-level cache: 4M Bytes, 8-way set associative, 64 byte line size, 2 lines per sector\n2CH1st-level data cache: 32K Bytes, 8-way set associative, 64 byte line size\n30H1st-level instruction cache: 32K Bytes, 8-way set associative, 64 byte line size\n40HNo 2nd-level cache or, if processor contains a valid 2nd-level cache, no 3rd-level cache\n41H2nd-level cache: 128 KBytes, 4-way set associative, 32 byte line size\n42H2nd-level cache: 256 KBytes, 4-way set associative, 32 byte line size\n43H2nd-level cache: 512 KBytes, 4-way set associative, 32 byte line size\n44H2nd-level cache: 1 MByte, 4-way set associative, 32 byte line size\n45H2nd-level cache: 2 MByte, 4-way set associative, 32 byte line size\n50HInstruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 64 entries\n51HInstruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 128 entries\n52HInstruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 256 entries\n5BHData TLB: 4 KByte and 4 MByte pages, 64 entries\n5CHData TLB: 4 KByte and 4 MByte pages,128 entries\n5DHData TLB: 4 KByte and 4 MByte pages,256 entries\n60H1st-level data cache: 16 KByte, 8-way set associative, 64 byte line size\n66H1st-level data cache: 8 KByte, 4-way set associative, 64 byte line size\n67H1st-level data cache: 16 KByte, 4-way set associative, 64 byte line size\n68H1st-level data cache: 32 KByte, 4-way set associative, 64 byte line size\n70HTrace cache: 12 K-�������µop, 8-way set associative\n71HTrace cache: 16 K-�������µop, 8-way set associative\n72HTrace cache: 32 K-�������µop, 8-way set associative\n78H2nd-level cache: 1 MByte, 4-way set associative, 64byte line size\n79H2nd-level cache: 128 KByte, 8-way set associative, 64 byte line size, 2 lines per sector\n7AH2nd-level cache: 256 KByte, 8-way set associative, 64 byte line size, 2 lines per sector\n7BH2nd-level cache: 512 KByte, 8-way set associative, 64 byte line size, 2 lines per sector\n7CH2nd-level cache: 1 MByte, 8-way set associative, 64 byte line size, 2 lines per sector\n7DH2nd-level cache: 2 MByte, 8-way set associative, 64byte line size\n7FH2nd-level cache: 512 KByte, 2-way set associative, 64-byte line size\n82H2nd-level cache: 256 KByte, 8-way set associative, 32 byte line size\n83H2nd-level cache: 512 KByte, 8-way set associative, 32 byte line size\n84H2nd-level cache: 1 MByte, 8-way set associative, 32 byte line size\n85H2nd-level cache: 2 MByte, 8-way set associative, 32 byte line size\n86H2nd-level cache: 512 KByte, 4-way set associative, 64 byte line size\n87H2nd-level cache: 1 MByte, 8-way set associative, 64 byte line size\nB0HInstruction TLB: 4 KByte Pages, 4-way set associative, 128 entries\nB3HData TLB: 4 KByte Pages, 4-way set associative, 128 entries\nF0H64-Byte Prefetching\nF1H128-Byte Prefetching")]),e._v(" "),s("p",[e._v("Example of Cache and TLB Interpretation The first member of the family of Pentium 4 processors returns the following information about caches and TLBs when the CPUID executes with an input value of 2: EAX 66 5B 50 01H EBX 0H ECX 0H EDX 00 7A 70 00H Which means: - The least-significant byte (byte 0) of register EAX is set to 01H. This indicates that CPUID needs to be executed once with an input value of 2 to retrieve complete information about caches and TLBs.")]),e._v(" "),s("p",[e._v("The most-significant bit of all four registers (EAX, EBX, ECX, and EDX) is set to 0, indicating that each register contains valid 1-byte descriptors.\nBytes 1, 2, and 3 of register EAX indicate that the processor has: 50H -> a 64-entry instruction TLB, for mapping 4-KByte and 2-MByte or 4-MByte pages;\t5BH -> a 64-entry data TLB, for mapping 4-KByte and 4-MByte pages; 66H -> an 8-KByte 1st level data cache, 4-way set associative, with a 64-Byte cache line size.\nThe descriptors in registers EBX and ECX are valid, but contain NULL descriptors.\nBytes 0, 1, 2, and 3 of register EDX indicate that the processor has: 00H -> NULL descriptor; 70H -> a 12-KByte 1st level code cache, 4-way set associative, with a 64-byte cache line size; 7AH -> a 256-KByte 2nd level cache, 8-way set associative, with a sectored, 64-byte cache line size; 00H -> NULL descriptor.")]),e._v(" "),s("p",[e._v("Methods for returning branding informationUse the following techniques to access branding information: 1. Processor brand string method; this method also returns the processor's maximum operating frequency 2. Processor brand index; this method uses a software supplied brand string table.\nThese two methods are discussed in the following sections. For methods that are available in early processors, see Section: \"Identification of Earlier IA-32 Processors\" in Chapter 14 of the IA-32 Intel Architecture Software Developer's Manual, Volume 1.\nThe Processor Brand String Method describes the algorithm used for detection of the brand string. Processor brand identification software should execute this algorithm on all IA-32 architecture compatible processors.\nThis method (introduced with Pentium 4 processors) returns an ASCII brand identification string and the maximum operating frequency of the processor to the EAX, EBX, ECX, and EDX registers.\nDetermination of Support for the Processor Brand StringEAX = 1\nCPUID\nIF (EAX >= 080000004H)\nTHEN\n* Processor Brand String Supported *\nELSE\n* Processor Brand String Not Supported *\nFI;")]),e._v(" "),s("p",[e._v("How Brand Strings Work To use the brand string method, execute CPUID with EAX input of 8000002H through 80000004H. For each input value, CPUID returns 16 ASCII characters using EAX, EBX, ECX, and EDX. The returned string will be NULL terminated.\nTable seven shows the brand string that is returned by the first processor in the Pentium 4 processor family.")]),e._v(" "),s("p",[e._v('Processor Brand String Returned with Pentium 4 Processor\nEAX Input ValueReturn ValuesASCII Equivalent\n80000002HEAX = 20202020H" "\n-EBX = 20202020H" "\n-ECX = 20202020H" "\n-EDX = 6E492020H"nI "\n80000003HEAX = 286C6574H"(let"\n-EBX = 50202952H"P )R"\n-ECX = 69746E65H"itne"\n-EDX = 52286D75H"R(mu"\n80000004HEAX = 20342029H" 4 )"\n-EBX = 20555043H" UPC"\n-ECX = 30303531H"0051"\n-EDX = 007A484DH"�zHM"')]),e._v(" "),s("p",[e._v('Extracting the Maximum Processor Frequency from Brand Strings provides an algorithm which software can use to extract the maximum processor operating frequency from the processor brand string.\nNOTE When a frequency is given in a brand string, it is the maximum qualified frequency of the processor, not the frequency at which the processor is currently running.\nAlgorithm for Extracting Maximum Processor FrequencyScan "Brand String" in Reverse Byte Order for ("zHM", "zHG", "zHT")\nIF Substring Matched\nSWITCH Substring\nCASE "zHM": Multiplier = 10^6\nCASE "zHG": Multiplier = 10^9\nCASE "zHT": Multiplier = 10^12\nScan Digits Until Blank In Reverse Order\nFreq = Reverse Digits To Decimal Value\n(* "Freq" = XY.Z if Digits = "Z.YX" *)\nMax. Qualifed Frequency = "Freq" x "Multiplier"\nELSE Report Error')]),e._v(" "),s("p",[e._v("The Processor Brand Index Method The brand index method (introduced with Pentium III Xeon processors) provides an entry point into a brand identification table that is maintained in memory by system software and is accessible from system- and user-level code. In this table, each brand index is associate with an ASCII brand identification string that identifies the official Intel family and model number of a processor.\nWhen CPUID executes with EAX set to 1, the processor returns a brand index to the low byte in EBX. Software can then use this index to locate the brand identification string for the processor in the brand identification table. The first entry (brand index 0) in this table is reserved, allowing for backward compatibility with processors that do not support the brand identification feature.\nTable eight shows brand indices that have identification strings associated with them.")]),e._v(" "),s("p",[e._v("Mapping of Brand Indices and IA-32 Processor Brand Strings\nBrand IndexBrand String\n00HThis processor does not support the brand identification feature\n01HIntel(R) Celeron(R) processor\n02HIntel(R) Pentium(R) III processor\n03HIntel(R) Pentium(R) III XeonTM processor; If processor signature = 000006B1h, then Intel(R) Celeron(R) processor\n04HIntel(R) Pentium(R) III processor\n06HMobile Intel(R) Pentium(R) III processor-M\n07HMobile Intel(R) Celeron(R) processor\n08HIntel(R) Pentium(R) 4 processor\n09HIntel(R) Pentium(R) 4 processor\n0AHIntel(R) Celeron(R) processor\n0BHIntel(R) Xeon(TM) processor; If processor signature = 00000F13h, then Intel(R) Xeon(TM) processor MP\n0CHIntel(R) Xeon(TM) processor MP\n0EHMobile Intel(R) Pentium(R) 4 processor-M; If processor signature = 00000F13h, then Intel(R) Xeon(TM) processor\n0FHMobile Intel(R) Celeron(R) processor\n11HMobile Genuine Intel(R) processor\n12HIntel(R) Celeron(R) M processor\n13HMobile Intel(R) Celeron(R) processor\n14HIntel(R) Celeron(R) processor\n15HMobile Genuine Intel(R) processor\n16HIntel(R) Pentium(R) M processor\n17HMobile Intel(R) Celeron(R) processor\n18H-0FFHRESERVED")]),e._v(" "),s("p",[e._v('|0H|EAX|Maximum Input Value for Basic CPUID Information (see second table)|-|EBX|"Genu"|-|ECX|"ntel"|-|EDX|"ineI"|01H|EAX|Version Information: Type, Family, Model, and Stepping ID|-|EBX|Bits 7-0: Brand Index|-|-|Bits 15-8: CLFLUSH line size (Value . 8 = cache line size in bytes)|-|-|Bits 23-16: Number of logical processors per physical processor; two for the Pentium 4 processor supporting Hyper-Threading Technology|-|-|Bits 31-24: Local APIC ID|-|ECX|Extended Feature Information (see fourth table)|-|EDX|Feature Information (see fifth table)|02H|EAX|Cache and TLB Information (see sixth table)|-|EBX|Cache and TLB Information|-|ECX|Cache and TLB Information|-|EDX|Cache and TLB Information|03H|EAX|Reserved.|-|EBX|Reserved.|-|ECX|Bits 00-31 of 96 bit processor serial number. (Available in Pentium III processor only; otherwise, the value in this register is reserved.)|-|EDX|Bits 32-63 of 96 bit processor serial number. (Available in Pentium III processor only; otherwise, the value in this register is reserved.)|-|-|NOTE: Processor serial number (PSN) is not supported in the Pentium 4 processor or later. On all models, use the PSN flag (returned using CPUID) to check for PSN support before accessing the feature. See AP-485, Intel Processor Identification and the CPUID Instruction (Order Number 241618) for more information on PSN.|04H|EAX|Bits 4-0: Cache Type**|-|-|Bits 7-5: Cache Level (starts at 1)|-|-|Bits 8: Self Initializing cache level (does not need SW initialization)|-|-|Bits 9: Fully Associative cache|-|-|Bits 13-10: Reserved|-|-|Bits 25-14: Number of threads sharing this cache*|-|-|Bits 31-26: Number of processor cores on this die (Multicore)'),s("em",[e._v("|-|EBX|Bits 11-00: L = System Coherency Line Size")]),e._v("|-|-|Bits 21-12: P = Physical Line partitions*|-|-|Bits 31-22: W = Ways of associativity*|-|ECX|Bits 31-00: S = Number of Sets*|-|EDX|Reserved = 0|-|-|0 = Null - No more caches|-|-|1 = Data Cache|-|-|2 = Instruction Cache|-|-|3 = Unified Cache|-|-|4-31 = Reserved|-|-|NOTE: CPUID leaves > 3 < 80000000 are only visible when IA32_CR_MISC_ENABLES.BOOT_NT4 (bit 22) is clear (Default)|5H|EAX|Bits 15-00: Smallest monitor-line size in bytes (default is processor's monitor granularity)|-|-|Bits 31-16: Reserved = 0|-|EBX|Bits 15-00: Largest monitor-line size in bytes (default is processor's monitor granularity)|-|-|Bits 31-16: Reserved = 0|-|ECX|Reserved = 0|-|EDX|Reserved = 0|"),s("em",[e._v("Add one to the value in the register file to get the number. For example, the number of processor cores is EAX[31:26]+1.|")]),e._v('* Cache Types fields|80000000H|EAX|Maximum Input Value for Extended Function CPUID Information (see second table).|-|EBX|Reserved|-|ECX|Reserved|-|EDX|Reserved|80000001H|EAX|Extended Processor Signature and Extended Feature Bits. (Currently reserved)|-|EBX|Reserved|-|ECX|Reserved|-|EDX|Reserved|80000002H|EAX|Processor Brand String|-|EBX|Processor Brand String Continued|-|ECX|Processor Brand String Continued|-|EDX|Processor Brand String Continued|80000003H|EAX|Processor Brand String Continued|-|EBX|Processor Brand String Continued|-|ECX|Processor Brand String Continued|-|EDX|Processor Brand String Continued|80000004H|EAX|Processor Brand String Continued|-|EBX|Processor Brand String Continued|-|ECX|Processor Brand String Continued|-|EDX|Processor Brand String Continued|80000005H|EAX|Reserved = 0|-|EBX|Reserved = 0|-|ECX|Reserved = 0|-|EDX|Reserved = 0|80000006H|EAX|Reserved = 0|-|EBX|Reserved = 0|-|ECX|Bits 0-7: Cache Line Size|-|-|Bits 15-12: L2 Associativity|-|-|Bits 31-16: Cache size in 1K units|-|EDX|Reserved = 0|-|80000007H EAX|Reserved = 0|-|EBX|Reserved = 0|-|ECX|Reserved = 0|-|EDX|Reserved = 0|80000008H|EAX|Reserved = 0|-|EBX|Reserved = 0|-|ECX|Reserved = 0|-|EDX|Reserved = 0|Earlier Intel486 Processors|CPUID Not Implemented|CPUID Not Implemented|Later Intel486 Processors and Pentium Processors|01H|Not Implemented|Pentium Pro and Pentium II Processors, Intel�������® Celeron��¢â���ž��¢ Processors|02H|Not Implemented|Pentium III Processors|03H|Not Implemented|Pentium 4 Processors|02H|80000004H|Intel Xeon Processors|02H|80000004H|Pentium M Processor|02H|80000004H|Pentium 4 Processor supporting Hyper-Threading Technology|05H|80000008H|0-3|Stepping ID|4-7|Model|8-11|Family ID|12-13|Processor Type|14-15|Reserved|16-19|Extended Model ID|20-27|Extended Family ID|28-31|Reserved|Original OEM Processor|00B|Intel OverDrive�������® Processor|01B|Dual processor (not applicable to Intel486 processors)|10B|Intel reserved|11B|NOTE See AP-485, Intel Processor Identification and the CPUID Instruction (Order Number 241618) and Chapter 14 in the IA-32 Intel Architecture Software Developer\'s Manual, Volume 1, for information on identifying earlier IA-32 processors.|0|SSE3|Streaming SIMD Extensions 3 (SSE3). A value of 1 indicates the processor supports this technology.|1-2|-|Reserved|3|MONITOR|MONITOR/MWAIT. A value of 1 indicates the processor supports this feature.|4|DS-CPL|CPL Qualified Debug Store. A value of 1 indicates the processor supports the extensions to the Debug Store feature to allow for branch message storage qualified by CPL.|5-6|-|Reserved|7|EST|Enhanced Intel SpeedStep�������® technology. A value of 1 indicates that the processor supports this technology.|8|TM2|Thermal Monitor 2. A value of 1 indicates whether the processor supports this technology.|9|-|Reserved|10|CNXT-ID|L1 Context ID. A value of 1 indicates the L1 data cache mode can be set to either adaptive mode or shared mode. A value of 0 indicates this feature is not supported. See definition of the IA32_MISC_ENABLE MSR Bit 24 (L1 Data Cache Context Mode) for details.|11-31|-|Reserved|0|FPU|Floating Point Unit On-Chip. The processor contains an x87 FPU.|1|VME|Virtual 8086 Mode Enhancements. Virtual 8086 mode enhancements, including CR4.VME for controlling the feature, CR4.PVI for protected mode virtual interrupts, software interrupt indirection, expansion of the TSS with the software indirection bitmap, and EFLAGS.VIF and EFLAGS.VIP flags.|2|DE|Debugging Extensions. Support for I/O breakpoints, including CR4.DE for controlling the feature, and optional trapping of accesses to DR4 and DR5.|3|PSE|Page Size Extension. Large pages of size 4 MByte are supported, including CR4.PSE for controlling the feature, the defined dirty bit in PDE (Page Directory Entries), optional reserved bit trapping in CR3, PDEs, and PTEs.|4|TSC|Time Stamp Counter. The RDTSC instruction is supported, including CR4.TSD for controlling privilege.|5|MSR|Model Specific Registers RDMSR and WRMSR Instructions. The RDMSR and WRMSR instructions are supported. Some of the MSRs are implementation dependent.|6|PAE|Physical Address Extension. Physical addresses greater than 32 bits are supported: extended page table entry formats, an extra level in the page translation tables is defined, 2-MByte pages are supported instead of 4 Mbyte pages if PAE bit is 1. The actual number of address bits beyond 32 is not defined, and is implementation specific.|7|MCE|Machine Check Exception. Exception 18 is defined for Machine Checks, including CR4.MCE for controlling the feature. This feature does not define the model-specific implementations of machine-check error logging, reporting, and processor shutdowns. Machine Check exception handlers may have to depend on processor version to do model specific processing of the exception, or test for the presence of the Machine Check feature.|8|CX8|CMPXCHG8B Instruction. The compare-and-exchange 8 bytes (64 bits) instruction is supported (implicitly locked and atomic).|9|APIC|APIC On-Chip. The processor contains an Advanced Programmable Interrupt Controller (APIC), responding to memory mapped commands in the physical address range FFFE0000H to FFFE0FFFH (by default - some processors permit the APIC to be relocated).|10|-|Reserved|11|SEP|SYSENTER and SYSEXIT Instructions. The SYSENTER and SYSEXIT and associated MSRs are supported. 12 MTRR Memory Type Range Registers. MTRRs are supported. The MTRRcap MSR contains feature bits that describe what memory types are supported, how many variable MTRRs are supported, and whether fixed MTRRs are supported.|13|PGE|PTE Global Bit. The global bit in page directory entries (PDEs) and page table entries (PTEs) is supported, indicating TLB entries that are common to different processes and need not be flushed. The CR4.PGE bit controls this feature.|14|MCA|Machine Check Architecture. The Machine Check Architecture, which provides a compatible mechanism for error reporting in P6 family, Pentium 4, Intel Xeon processors, and future processors, is supported. The MCG_CAP MSR contains feature bits describing how many banks of error reporting MSRs are supported.|15|CMOV|Conditional Move Instructions. The conditional move instruction CMOV is supported. In addition, if x87 FPU is present as indicated by the CPUID.FPU feature bit, then the FCOMI and FCMOV instructions are supported|16|PAT|Page Attribute Table. Page Attribute Table is supported. This feature augments the Memory Type Range Registers (MTRRs), allowing an operating system to specify attributes of memory on a 4K granularity through a linear address.|17|PSE-36|36-Bit Page Size Extension. Extended 4-MByte pages that are capable of addressing physical memory beyond 4 GBytes are supported. This feature indicates that the upper four bits of the physical address of the 4-MByte page is encoded by bits 13-16 of the page directory entry.|18|PSN|Processor Serial Number. The processor supports the 96-bit processor identification number feature and the feature is enabled.|19|CLFSH|CLFLUSH Instruction. CLFLUSH Instruction is supported. 20 Reserved Reserved|21|DS|Debug Store. The processor supports the ability to write debug information into a memory resident buffer. This feature is used by the branch trace store (BTS) and precise event-based sampling (PEBS) facilities (see Chapter 15, Debugging and Performance Monitoring, in the IA-32 Intel Architecture Software Developer\'s Manual, Volume 3).|22|ACPI|Thermal Monitor and Software Controlled Clock Facilities. The processor implements internal MSRs that allow processor temperature to be monitored and processor performance to be modulated in predefined duty cycles under software control.|23|MMX|Intel MMX Technology. The processor supports the Intel MMX technology.|24|FXSR|FXSAVE and FXRSTOR Instructions. The FXSAVE and FXRSTOR instructions are supported for fast save and restore of the floating point context. Presence of this bit also indicates that CR4.OSFXSR is available for an operating system to indicate that it supports the FXSAVE and FXRSTOR instructions.|25|SSE|SSE. The processor supports the SSE extensions.|26|SSE2|SSE2. The processor supports the SSE2 extensions.|27|SS|Self Snoop. The processor supports the management of conflicting memory types by performing a snoop of its own cache structure for transactions issued to the bus.|28|HTT|Hyper-Threading Technology. The processor supports Hyper-Threading Technology.|29|TM|Thermal Monitor. The processor implements the thermal monitor automatic thermal control circuitry (TCC).|30|-|Reserved|31|PBE|Pending Break Enable. The processor supports the use of the FERR#/PBE# pin when the processor is in the stop-clock state (STPCLK# is asserted) to signal the processor that an interrupt is pending and that the processor should return to normal operation to handle the interrupt. Bit 10 (PBE enable) in the IA32_MISC_ENABLE MSR enables this capability.|00H|Null descriptor|01H|Instruction TLB: 4 KByte Pages, 4-way set associative, 32 entries|02H|Instruction TLB: 4 MByte Pages, 4-way set associative, 2 entries|03H|Data TLB: 4KByte Pages, 4-way set associative, 64 entries|04H|Data TLB: 4MByte Pages, 4-way set associative, 8 entries|06H|1st-level instruction cache: 8 KBytes, 4-way set associative, 32 byte line size|08H|1st-level instruction cache: 16 KBytes, 4-way set associative, 32 byte line size|0AH|1st-level data cache: 8 KBytes, 2-way set associative, 32 byte line size|0CH|1st-level data cache: 16 KBytes, 4-way set associative, 32 byte line size|22H|3rd-level cache: 512 KBytes, 4-way set associative, 64 byte line size, 2 lines per sector|23H|3rd-level cache: 1 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector|25H|3rd-level cache: 2 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector|29H|3rd-level cache: 4M Bytes, 8-way set associative, 64 byte line size, 2 lines per sector|2CH|1st-level data cache: 32K Bytes, 8-way set associative, 64 byte line size|30H|1st-level instruction cache: 32K Bytes, 8-way set associative, 64 byte line size|40H|No 2nd-level cache or, if processor contains a valid 2nd-level cache, no 3rd-level cache|41H|2nd-level cache: 128 KBytes, 4-way set associative, 32 byte line size|42H|2nd-level cache: 256 KBytes, 4-way set associative, 32 byte line size|43H|2nd-level cache: 512 KBytes, 4-way set associative, 32 byte line size|44H|2nd-level cache: 1 MByte, 4-way set associative, 32 byte line size|45H|2nd-level cache: 2 MByte, 4-way set associative, 32 byte line size|50H|Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 64 entries|51H|Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 128 entries|52H|Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 256 entries|5BH|Data TLB: 4 KByte and 4 MByte pages, 64 entries|5CH|Data TLB: 4 KByte and 4 MByte pages,128 entries|5DH|Data TLB: 4 KByte and 4 MByte pages,256 entries|60H|1st-level data cache: 16 KByte, 8-way set associative, 64 byte line size|66H|1st-level data cache: 8 KByte, 4-way set associative, 64 byte line size|67H|1st-level data cache: 16 KByte, 4-way set associative, 64 byte line size|68H|1st-level data cache: 32 KByte, 4-way set associative, 64 byte line size|70H|Trace cache: 12 K-�������µop, 8-way set associative|71H|Trace cache: 16 K-�������µop, 8-way set associative|72H|Trace cache: 32 K-�������µop, 8-way set associative|78H|2nd-level cache: 1 MByte, 4-way set associative, 64byte line size|79H|2nd-level cache: 128 KByte, 8-way set associative, 64 byte line size, 2 lines per sector|7AH|2nd-level cache: 256 KByte, 8-way set associative, 64 byte line size, 2 lines per sector|7BH|2nd-level cache: 512 KByte, 8-way set associative, 64 byte line size, 2 lines per sector|7CH|2nd-level cache: 1 MByte, 8-way set associative, 64 byte line size, 2 lines per sector|7DH|2nd-level cache: 2 MByte, 8-way set associative, 64byte line size|7FH|2nd-level cache: 512 KByte, 2-way set associative, 64-byte line size|82H|2nd-level cache: 256 KByte, 8-way set associative, 32 byte line size|83H|2nd-level cache: 512 KByte, 8-way set associative, 32 byte line size|84H|2nd-level cache: 1 MByte, 8-way set associative, 32 byte line size|85H|2nd-level cache: 2 MByte, 8-way set associative, 32 byte line size|86H|2nd-level cache: 512 KByte, 4-way set associative, 64 byte line size|87H|2nd-level cache: 1 MByte, 8-way set associative, 64 byte line size|B0H|Instruction TLB: 4 KByte Pages, 4-way set associative, 128 entries|B3H|Data TLB: 4 KByte Pages, 4-way set associative, 128 entries|F0H|64-Byte Prefetching|F1H|128-Byte Prefetching|80000002H|EAX = 20202020H|" "|-|EBX = 20202020H|" "|-|ECX = 20202020H|" "|-|EDX = 6E492020H|"nI "|80000003H|EAX = 286C6574H|"(let"|-|EBX = 50202952H|"P )R"|-|ECX = 69746E65H|"itne"|-|EDX = 52286D75H|"R(mu"|80000004H|EAX = 20342029H|" 4 )"|-|EBX = 20555043H|" UPC"|-|ECX = 30303531H|"0051"|-|EDX = 007A484DH|"�zHM"|00H|This processor does not support the brand identification feature|01H|Intel(R) Celeron(R) processor|02H|Intel(R) Pentium(R) III processor|03H|Intel(R) Pentium(R) III XeonTM processor; If processor signature = 000006B1h, then Intel(R) Celeron(R) processor|04H|Intel(R) Pentium(R) III processor|06H|Mobile Intel(R) Pentium(R) III processor-M|07H|Mobile Intel(R) Celeron(R) processor|08H|Intel(R) Pentium(R) 4 processor|09H|Intel(R) Pentium(R) 4 processor|0AH|Intel(R) Celeron(R) processor|0BH|Intel(R) Xeon(TM) processor; If processor signature = 00000F13h, then Intel(R) Xeon(TM) processor MP|0CH|Intel(R) Xeon(TM) processor MP|0EH|Mobile Intel(R) Pentium(R) 4 processor-M; If processor signature = 00000F13h, then Intel(R) Xeon(TM) processor|0FH|Mobile Intel(R) Celeron(R) processor|11H|Mobile Genuine Intel(R) processor|12H|Intel(R) Celeron(R) M processor|13H|Mobile Intel(R) Celeron(R) processor|14H|Intel(R) Celeron(R) processor|15H|Mobile Genuine Intel(R) processor|16H|Intel(R) Pentium(R) M processor|17H|Mobile Intel(R) Celeron(R) processor|18H-0FFH|RESERVED|\n|\n|0H|EAX|Maximum Input Value for Basic CPUID Information (see second table)|\n|-|EBX|"Genu"|\n|-|ECX|"ntel"|\n|-|EDX|"ineI"|\n|01H|EAX|Version Information: Type, Family, Model, and Stepping ID|\n|-|EBX|Bits 7-0: Brand Index|\n|-|-|Bits 15-8: CLFLUSH line size (Value . 8 = cache line size in bytes)|\n|-|-|Bits 23-16: Number of logical processors per physical processor; two for the Pentium 4 processor supporting Hyper-Threading Technology|\n|-|-|Bits 31-24: Local APIC ID|\n|-|ECX|Extended Feature Information (see fourth table)|\n|-|EDX|Feature Information (see fifth table)|\n|02H|EAX|Cache and TLB Information (see sixth table)|\n|-|EBX|Cache and TLB Information|\n|-|ECX|Cache and TLB Information|\n|-|EDX|Cache and TLB Information|\n|03H|EAX|Reserved.|\n|-|EBX|Reserved.|\n|-|ECX|Bits 00-31 of 96 bit processor serial number. (Available in Pentium III processor only; otherwise, the value in this register is reserved.)|\n|-|EDX|Bits 32-63 of 96 bit processor serial number. (Available in Pentium III processor only; otherwise, the value in this register is reserved.)|\n|-|-|NOTE: Processor serial number (PSN) is not supported in the Pentium 4 processor or later. On all models, use the PSN flag (returned using CPUID) to check for PSN support before accessing the feature. See AP-485, Intel Processor Identification and the CPUID Instruction (Order Number 241618) for more information on PSN.|\n|04H|EAX|Bits 4-0: Cache Type**|\n|-|-|Bits 7-5: Cache Level (starts at 1)|\n|-|-|Bits 8: Self Initializing cache level (does not need SW initialization)|\n|-|-|Bits 9: Fully Associative cache|\n|-|-|Bits 13-10: Reserved|\n|-|-|Bits 25-14: Number of threads sharing this cache*|\n|-|-|Bits 31-26: Number of processor cores on this die (Multicore)'),s("em",[e._v("|\n|-|EBX|Bits 11-00: L = System Coherency Line Size")]),e._v("|\n|-|-|Bits 21-12: P = Physical Line partitions*|\n|-|-|Bits 31-22: W = Ways of associativity*|\n|-|ECX|Bits 31-00: S = Number of Sets*|\n|-|EDX|Reserved = 0|\n|-|-|0 = Null - No more caches|\n|-|-|1 = Data Cache|\n|-|-|2 = Instruction Cache|\n|-|-|3 = Unified Cache|\n|-|-|4-31 = Reserved|\n|-|-|NOTE: CPUID leaves > 3 < 80000000 are only visible when IA32_CR_MISC_ENABLES.BOOT_NT4 (bit 22) is clear (Default)|\n|5H|EAX|Bits 15-00: Smallest monitor-line size in bytes (default is processor's monitor granularity)|\n|-|-|Bits 31-16: Reserved = 0|\n|-|EBX|Bits 15-00: Largest monitor-line size in bytes (default is processor's monitor granularity)|\n|-|-|Bits 31-16: Reserved = 0|\n|-|ECX|Reserved = 0|\n|-|EDX|Reserved = 0|\n|"),s("em",[e._v("Add one to the value in the register file to get the number. For example, the number of processor cores is EAX[31:26]+1.|\n|")]),e._v('* Cache Types fields|\n|\n|80000000H|EAX|Maximum Input Value for Extended Function CPUID Information (see second table).|\n|-|EBX|Reserved|\n|-|ECX|Reserved|\n|-|EDX|Reserved|\n|80000001H|EAX|Extended Processor Signature and Extended Feature Bits. (Currently reserved)|\n|-|EBX|Reserved|\n|-|ECX|Reserved|\n|-|EDX|Reserved|\n|80000002H|EAX|Processor Brand String|\n|-|EBX|Processor Brand String Continued|\n|-|ECX|Processor Brand String Continued|\n|-|EDX|Processor Brand String Continued|\n|80000003H|EAX|Processor Brand String Continued|\n|-|EBX|Processor Brand String Continued|\n|-|ECX|Processor Brand String Continued|\n|-|EDX|Processor Brand String Continued|\n|80000004H|EAX|Processor Brand String Continued|\n|-|EBX|Processor Brand String Continued|\n|-|ECX|Processor Brand String Continued|\n|-|EDX|Processor Brand String Continued|\n|80000005H|EAX|Reserved = 0|\n|-|EBX|Reserved = 0|\n|-|ECX|Reserved = 0|\n|-|EDX|Reserved = 0|\n|80000006H|EAX|Reserved = 0|\n|-|EBX|Reserved = 0|\n|-|ECX|Bits 0-7: Cache Line Size|\n|-|-|Bits 15-12: L2 Associativity|\n|-|-|Bits 31-16: Cache size in 1K units|\n|-|EDX|Reserved = 0|\n|-|80000007H EAX|Reserved = 0|\n|-|EBX|Reserved = 0|\n|-|ECX|Reserved = 0|\n|-|EDX|Reserved = 0|\n|80000008H|EAX|Reserved = 0|\n|-|EBX|Reserved = 0|\n|-|ECX|Reserved = 0|\n|-|EDX|Reserved = 0|\n|\n|Earlier Intel486 Processors|CPUID Not Implemented|CPUID Not Implemented|\n|Later Intel486 Processors and Pentium Processors|01H|Not Implemented|\n|Pentium Pro and Pentium II Processors, Intel�������® Celeron��¢â���ž��¢ Processors|02H|Not Implemented|\n|Pentium III Processors|03H|Not Implemented|\n|Pentium 4 Processors|02H|80000004H|\n|Intel Xeon Processors|02H|80000004H|\n|Pentium M Processor|02H|80000004H|\n|Pentium 4 Processor supporting Hyper-Threading Technology|05H|80000008H|\n|\n|0-3|Stepping ID|\n|4-7|Model|\n|8-11|Family ID|\n|12-13|Processor Type|\n|14-15|Reserved|\n|16-19|Extended Model ID|\n|20-27|Extended Family ID|\n|28-31|Reserved|\n|\n|Original OEM Processor|00B|\n|Intel OverDrive�������® Processor|01B|\n|Dual processor (not applicable to Intel486 processors)|10B|\n|Intel reserved|11B|\n|NOTE See AP-485, Intel Processor Identification and the CPUID Instruction (Order Number 241618) and Chapter 14 in the IA-32 Intel Architecture Software Developer\'s Manual, Volume 1, for information on identifying earlier IA-32 processors.|\n|\n|0|SSE3|Streaming SIMD Extensions 3 (SSE3). A value of 1 indicates the processor supports this technology.|\n|1-2|-|Reserved|\n|3|MONITOR|MONITOR/MWAIT. A value of 1 indicates the processor supports this feature.|\n|4|DS-CPL|CPL Qualified Debug Store. A value of 1 indicates the processor supports the extensions to the Debug Store feature to allow for branch message storage qualified by CPL.|\n|5-6|-|Reserved|\n|7|EST|Enhanced Intel SpeedStep�������® technology. A value of 1 indicates that the processor supports this technology.|\n|8|TM2|Thermal Monitor 2. A value of 1 indicates whether the processor supports this technology.|\n|9|-|Reserved|\n|10|CNXT-ID|L1 Context ID. A value of 1 indicates the L1 data cache mode can be set to either adaptive mode or shared mode. A value of 0 indicates this feature is not supported. See definition of the IA32_MISC_ENABLE MSR Bit 24 (L1 Data Cache Context Mode) for details.|\n|11-31|-|Reserved|\n|\n|0|FPU|Floating Point Unit On-Chip. The processor contains an x87 FPU.|\n|1|VME|Virtual 8086 Mode Enhancements. Virtual 8086 mode enhancements, including CR4.VME for controlling the feature, CR4.PVI for protected mode virtual interrupts, software interrupt indirection, expansion of the TSS with the software indirection bitmap, and EFLAGS.VIF and EFLAGS.VIP flags.|\n|2|DE|Debugging Extensions. Support for I/O breakpoints, including CR4.DE for controlling the feature, and optional trapping of accesses to DR4 and DR5.|\n|3|PSE|Page Size Extension. Large pages of size 4 MByte are supported, including CR4.PSE for controlling the feature, the defined dirty bit in PDE (Page Directory Entries), optional reserved bit trapping in CR3, PDEs, and PTEs.|\n|4|TSC|Time Stamp Counter. The RDTSC instruction is supported, including CR4.TSD for controlling privilege.|\n|5|MSR|Model Specific Registers RDMSR and WRMSR Instructions. The RDMSR and WRMSR instructions are supported. Some of the MSRs are implementation dependent.|\n|6|PAE|Physical Address Extension. Physical addresses greater than 32 bits are supported: extended page table entry formats, an extra level in the page translation tables is defined, 2-MByte pages are supported instead of 4 Mbyte pages if PAE bit is 1. The actual number of address bits beyond 32 is not defined, and is implementation specific.|\n|7|MCE|Machine Check Exception. Exception 18 is defined for Machine Checks, including CR4.MCE for controlling the feature. This feature does not define the model-specific implementations of machine-check error logging, reporting, and processor shutdowns. Machine Check exception handlers may have to depend on processor version to do model specific processing of the exception, or test for the presence of the Machine Check feature.|\n|8|CX8|CMPXCHG8B Instruction. The compare-and-exchange 8 bytes (64 bits) instruction is supported (implicitly locked and atomic).|\n|9|APIC|APIC On-Chip. The processor contains an Advanced Programmable Interrupt Controller (APIC), responding to memory mapped commands in the physical address range FFFE0000H to FFFE0FFFH (by default - some processors permit the APIC to be relocated).|\n|10|-|Reserved|\n|11|SEP|SYSENTER and SYSEXIT Instructions. The SYSENTER and SYSEXIT and associated MSRs are supported. 12 MTRR Memory Type Range Registers. MTRRs are supported. The MTRRcap MSR contains feature bits that describe what memory types are supported, how many variable MTRRs are supported, and whether fixed MTRRs are supported.|\n|13|PGE|PTE Global Bit. The global bit in page directory entries (PDEs) and page table entries (PTEs) is supported, indicating TLB entries that are common to different processes and need not be flushed. The CR4.PGE bit controls this feature.|\n|14|MCA|Machine Check Architecture. The Machine Check Architecture, which provides a compatible mechanism for error reporting in P6 family, Pentium 4, Intel Xeon processors, and future processors, is supported. The MCG_CAP MSR contains feature bits describing how many banks of error reporting MSRs are supported.|\n|15|CMOV|Conditional Move Instructions. The conditional move instruction CMOV is supported. In addition, if x87 FPU is present as indicated by the CPUID.FPU feature bit, then the FCOMI and FCMOV instructions are supported|\n|16|PAT|Page Attribute Table. Page Attribute Table is supported. This feature augments the Memory Type Range Registers (MTRRs), allowing an operating system to specify attributes of memory on a 4K granularity through a linear address.|\n|17|PSE-36|36-Bit Page Size Extension. Extended 4-MByte pages that are capable of addressing physical memory beyond 4 GBytes are supported. This feature indicates that the upper four bits of the physical address of the 4-MByte page is encoded by bits 13-16 of the page directory entry.|\n|18|PSN|Processor Serial Number. The processor supports the 96-bit processor identification number feature and the feature is enabled.|\n|19|CLFSH|CLFLUSH Instruction. CLFLUSH Instruction is supported. 20 Reserved Reserved|\n|21|DS|Debug Store. The processor supports the ability to write debug information into a memory resident buffer. This feature is used by the branch trace store (BTS) and precise event-based sampling (PEBS) facilities (see Chapter 15, Debugging and Performance Monitoring, in the IA-32 Intel Architecture Software Developer\'s Manual, Volume 3).|\n|22|ACPI|Thermal Monitor and Software Controlled Clock Facilities. The processor implements internal MSRs that allow processor temperature to be monitored and processor performance to be modulated in predefined duty cycles under software control.|\n|23|MMX|Intel MMX Technology. The processor supports the Intel MMX technology.|\n|24|FXSR|FXSAVE and FXRSTOR Instructions. The FXSAVE and FXRSTOR instructions are supported for fast save and restore of the floating point context. Presence of this bit also indicates that CR4.OSFXSR is available for an operating system to indicate that it supports the FXSAVE and FXRSTOR instructions.|\n|25|SSE|SSE. The processor supports the SSE extensions.|\n|26|SSE2|SSE2. The processor supports the SSE2 extensions.|\n|27|SS|Self Snoop. The processor supports the management of conflicting memory types by performing a snoop of its own cache structure for transactions issued to the bus.|\n|28|HTT|Hyper-Threading Technology. The processor supports Hyper-Threading Technology.|\n|29|TM|Thermal Monitor. The processor implements the thermal monitor automatic thermal control circuitry (TCC).|\n|30|-|Reserved|\n|31|PBE|Pending Break Enable. The processor supports the use of the FERR#/PBE# pin when the processor is in the stop-clock state (STPCLK# is asserted) to signal the processor that an interrupt is pending and that the processor should return to normal operation to handle the interrupt. Bit 10 (PBE enable) in the IA32_MISC_ENABLE MSR enables this capability.|\n|\n|00H|Null descriptor|\n|01H|Instruction TLB: 4 KByte Pages, 4-way set associative, 32 entries|\n|02H|Instruction TLB: 4 MByte Pages, 4-way set associative, 2 entries|\n|03H|Data TLB: 4KByte Pages, 4-way set associative, 64 entries|\n|04H|Data TLB: 4MByte Pages, 4-way set associative, 8 entries|\n|06H|1st-level instruction cache: 8 KBytes, 4-way set associative, 32 byte line size|\n|08H|1st-level instruction cache: 16 KBytes, 4-way set associative, 32 byte line size|\n|0AH|1st-level data cache: 8 KBytes, 2-way set associative, 32 byte line size|\n|0CH|1st-level data cache: 16 KBytes, 4-way set associative, 32 byte line size|\n|22H|3rd-level cache: 512 KBytes, 4-way set associative, 64 byte line size, 2 lines per sector|\n|23H|3rd-level cache: 1 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector|\n|25H|3rd-level cache: 2 MBytes, 8-way set associative, 64 byte line size, 2 lines per sector|\n|29H|3rd-level cache: 4M Bytes, 8-way set associative, 64 byte line size, 2 lines per sector|\n|2CH|1st-level data cache: 32K Bytes, 8-way set associative, 64 byte line size|\n|30H|1st-level instruction cache: 32K Bytes, 8-way set associative, 64 byte line size|\n|40H|No 2nd-level cache or, if processor contains a valid 2nd-level cache, no 3rd-level cache|\n|41H|2nd-level cache: 128 KBytes, 4-way set associative, 32 byte line size|\n|42H|2nd-level cache: 256 KBytes, 4-way set associative, 32 byte line size|\n|43H|2nd-level cache: 512 KBytes, 4-way set associative, 32 byte line size|\n|44H|2nd-level cache: 1 MByte, 4-way set associative, 32 byte line size|\n|45H|2nd-level cache: 2 MByte, 4-way set associative, 32 byte line size|\n|50H|Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 64 entries|\n|51H|Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 128 entries|\n|52H|Instruction TLB: 4 KByte and 2-MByte or 4-MByte pages, 256 entries|\n|5BH|Data TLB: 4 KByte and 4 MByte pages, 64 entries|\n|5CH|Data TLB: 4 KByte and 4 MByte pages,128 entries|\n|5DH|Data TLB: 4 KByte and 4 MByte pages,256 entries|\n|60H|1st-level data cache: 16 KByte, 8-way set associative, 64 byte line size|\n|66H|1st-level data cache: 8 KByte, 4-way set associative, 64 byte line size|\n|67H|1st-level data cache: 16 KByte, 4-way set associative, 64 byte line size|\n|68H|1st-level data cache: 32 KByte, 4-way set associative, 64 byte line size|\n|70H|Trace cache: 12 K-�������µop, 8-way set associative|\n|71H|Trace cache: 16 K-�������µop, 8-way set associative|\n|72H|Trace cache: 32 K-�������µop, 8-way set associative|\n|78H|2nd-level cache: 1 MByte, 4-way set associative, 64byte line size|\n|79H|2nd-level cache: 128 KByte, 8-way set associative, 64 byte line size, 2 lines per sector|\n|7AH|2nd-level cache: 256 KByte, 8-way set associative, 64 byte line size, 2 lines per sector|\n|7BH|2nd-level cache: 512 KByte, 8-way set associative, 64 byte line size, 2 lines per sector|\n|7CH|2nd-level cache: 1 MByte, 8-way set associative, 64 byte line size, 2 lines per sector|\n|7DH|2nd-level cache: 2 MByte, 8-way set associative, 64byte line size|\n|7FH|2nd-level cache: 512 KByte, 2-way set associative, 64-byte line size|\n|82H|2nd-level cache: 256 KByte, 8-way set associative, 32 byte line size|\n|83H|2nd-level cache: 512 KByte, 8-way set associative, 32 byte line size|\n|84H|2nd-level cache: 1 MByte, 8-way set associative, 32 byte line size|\n|85H|2nd-level cache: 2 MByte, 8-way set associative, 32 byte line size|\n|86H|2nd-level cache: 512 KByte, 4-way set associative, 64 byte line size|\n|87H|2nd-level cache: 1 MByte, 8-way set associative, 64 byte line size|\n|B0H|Instruction TLB: 4 KByte Pages, 4-way set associative, 128 entries|\n|B3H|Data TLB: 4 KByte Pages, 4-way set associative, 128 entries|\n|F0H|64-Byte Prefetching|\n|F1H|128-Byte Prefetching|\n|\n|80000002H|EAX = 20202020H|" "|\n|-|EBX = 20202020H|" "|\n|-|ECX = 20202020H|" "|\n|-|EDX = 6E492020H|"nI "|\n|80000003H|EAX = 286C6574H|"(let"|\n|-|EBX = 50202952H|"P )R"|\n|-|ECX = 69746E65H|"itne"|\n|-|EDX = 52286D75H|"R(mu"|\n|80000004H|EAX = 20342029H|" 4 )"|\n|-|EBX = 20555043H|" UPC"|\n|-|ECX = 30303531H|"0051"|\n|-|EDX = 007A484DH|"�zHM"|\n|\n|00H|This processor does not support the brand identification feature|\n|01H|Intel(R) Celeron(R) processor|\n|02H|Intel(R) Pentium(R) III processor|\n|03H|Intel(R) Pentium(R) III XeonTM processor; If processor signature = 000006B1h, then Intel(R) Celeron(R) processor|\n|04H|Intel(R) Pentium(R) III processor|\n|06H|Mobile Intel(R) Pentium(R) III processor-M|\n|07H|Mobile Intel(R) Celeron(R) processor|\n|08H|Intel(R) Pentium(R) 4 processor|\n|09H|Intel(R) Pentium(R) 4 processor|\n|0AH|Intel(R) Celeron(R) processor|\n|0BH|Intel(R) Xeon(TM) processor; If processor signature = 00000F13h, then Intel(R) Xeon(TM) processor MP|\n|0CH|Intel(R) Xeon(TM) processor MP|\n|0EH|Mobile Intel(R) Pentium(R) 4 processor-M; If processor signature = 00000F13h, then Intel(R) Xeon(TM) processor|\n|0FH|Mobile Intel(R) Celeron(R) processor|\n|11H|Mobile Genuine Intel(R) processor|\n|12H|Intel(R) Celeron(R) M processor|\n|13H|Mobile Intel(R) Celeron(R) processor|\n|14H|Intel(R) Celeron(R) processor|\n|15H|Mobile Genuine Intel(R) processor|\n|16H|Intel(R) Pentium(R) M processor|\n|17H|Mobile Intel(R) Celeron(R) processor|\n|18H-0FFH|RESERVED|')]),e._v(" "),s("h2",{attrs:{id:"operation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#operation"}},[e._v("#")]),e._v(" Operation")]),e._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("switch")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("EAX"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("case")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v("\n\t\tEAX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("HighestCPUIDInput")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//highest basic function input value understood by CPUID")]),e._v("\n\t\tEBX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" VendorIdentificationString"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("0.")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v(".3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEDX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" VendorIdentificationString"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("4.")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v(".7")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tECX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" VendorIdentificationString"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("8.")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v(".11")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("break")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("case")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v("\n\t\tEAX"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("0.")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v(".3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" SteppingID"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEAX"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("4.")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v(".7")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Model"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEAX"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("8.")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v(".11")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Family"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEAX"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("12.")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v(".13")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" ProcessorType"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEAX"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("14.")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v(".15")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEAX"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("16.")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v(".19")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" ExtendedModel"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEAX"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("20.")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v(".23")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" ExtendedFamily"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEAX"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("24.")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v(".31")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEBX"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("0.")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v(".7")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" BrandIndex"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEBX"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("8.")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v(".15")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" CLFLUSHLineSize"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEBX"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("16.")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v(".23")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEBX"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("24.")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v(".31")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" InitialAPICID"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tECX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" ExtendedFeatureFlags"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEDX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" FeatureFlags"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("break")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("case")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("2")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v("\n\t\tEAX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("CacheAndTLBInformation")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEBX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("CacheAndTLBInformation")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//0")]),e._v("\n\t\tECX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("CacheAndTLBInformation")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//0")]),e._v("\n\t\tEDX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("CacheAndTLBInformation")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("break")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("case")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("3")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v("\n\t\tEAX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEBX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[e._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[e._v("ifdef")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token expression"}},[e._v("PentiumIII")])]),e._v("\n\t\tECX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" ProcessorSerialNumber"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("0.")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v(".31")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEDX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" ProcessorSerialNumber"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("32.")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v(".63")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[e._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[e._v("else")])]),e._v("\n\t\tECX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEDX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[e._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[e._v("endif")])]),e._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("break")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("case")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("4")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v("\n\t\tEAX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("DeterministicCacheParametersLeaf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEBX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("DeterministicCacheParametersLeaf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tECX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("DeterministicCacheParametersLeaf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEDX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("DeterministicCacheParametersLeaf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("break")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("case")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("5")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v("\n\t\tEAX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("MONITORMWAITLeaf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEBX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("MONITORMWAITLeaf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tECX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("MONITORMWAITLeaf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEDX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("MONITORMWAITLeaf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("break")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("case")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("0x80000000")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v("\n\t\tEAX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("HighestExtendedCPUIDInput")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//highest extended function input value understood by CPUID")]),e._v("\n\t\tEBX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tECX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEDX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("break")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("case")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("0x80000001")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v("\n\t\tEAX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" ExtendedProcessorFeatureSignature"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//Currently Reserved")]),e._v("\n\t\tEBX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tECX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEDX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("break")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("case")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("0x80000002")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v("\n\t\tEAX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" ProcessorBrandString"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("0.")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v(".3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEBX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" ProcessorBrandString"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("4.")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v(".7")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tECX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" ProcessorBrandString"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("8.")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v(".11")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEDX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" ProcessorBrandString"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("12.")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v(".15")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("break")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("case")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("0x80000003")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v("\n\t\tEAX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" ProcessorBrandString"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("16.")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v(".19")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEBX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" ProcessorBrandString"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("20.")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v(".23")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tECX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" ProcessorBrandString"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("24.")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v(".27")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEDX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" ProcessorBrandString"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("28.")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v(".31")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("break")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\t\t\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("case")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("0x80000004")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v("\n\t\tEAX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEBX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tECX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEDX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("break")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("case")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("0x80000006")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v("\n\t\tEAX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEBX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tECX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" CacheInformation"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEDX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("break")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("case")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("0x80000007")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v("\n\t\tEAX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEBX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tECX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEDX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("break")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("case")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("0x80000008")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v("\n\t\tEAX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEBX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tECX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEDX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("break")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("default")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//EAX > highest value recognized by CPUID")]),e._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//undefined")]),e._v("\n\t\tEAX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEBX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tECX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tEDX "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Reserved"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("break")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br"),s("span",{staticClass:"line-number"},[e._v("33")]),s("br"),s("span",{staticClass:"line-number"},[e._v("34")]),s("br"),s("span",{staticClass:"line-number"},[e._v("35")]),s("br"),s("span",{staticClass:"line-number"},[e._v("36")]),s("br"),s("span",{staticClass:"line-number"},[e._v("37")]),s("br"),s("span",{staticClass:"line-number"},[e._v("38")]),s("br"),s("span",{staticClass:"line-number"},[e._v("39")]),s("br"),s("span",{staticClass:"line-number"},[e._v("40")]),s("br"),s("span",{staticClass:"line-number"},[e._v("41")]),s("br"),s("span",{staticClass:"line-number"},[e._v("42")]),s("br"),s("span",{staticClass:"line-number"},[e._v("43")]),s("br"),s("span",{staticClass:"line-number"},[e._v("44")]),s("br"),s("span",{staticClass:"line-number"},[e._v("45")]),s("br"),s("span",{staticClass:"line-number"},[e._v("46")]),s("br"),s("span",{staticClass:"line-number"},[e._v("47")]),s("br"),s("span",{staticClass:"line-number"},[e._v("48")]),s("br"),s("span",{staticClass:"line-number"},[e._v("49")]),s("br"),s("span",{staticClass:"line-number"},[e._v("50")]),s("br"),s("span",{staticClass:"line-number"},[e._v("51")]),s("br"),s("span",{staticClass:"line-number"},[e._v("52")]),s("br"),s("span",{staticClass:"line-number"},[e._v("53")]),s("br"),s("span",{staticClass:"line-number"},[e._v("54")]),s("br"),s("span",{staticClass:"line-number"},[e._v("55")]),s("br"),s("span",{staticClass:"line-number"},[e._v("56")]),s("br"),s("span",{staticClass:"line-number"},[e._v("57")]),s("br"),s("span",{staticClass:"line-number"},[e._v("58")]),s("br"),s("span",{staticClass:"line-number"},[e._v("59")]),s("br"),s("span",{staticClass:"line-number"},[e._v("60")]),s("br"),s("span",{staticClass:"line-number"},[e._v("61")]),s("br"),s("span",{staticClass:"line-number"},[e._v("62")]),s("br"),s("span",{staticClass:"line-number"},[e._v("63")]),s("br"),s("span",{staticClass:"line-number"},[e._v("64")]),s("br"),s("span",{staticClass:"line-number"},[e._v("65")]),s("br"),s("span",{staticClass:"line-number"},[e._v("66")]),s("br"),s("span",{staticClass:"line-number"},[e._v("67")]),s("br"),s("span",{staticClass:"line-number"},[e._v("68")]),s("br"),s("span",{staticClass:"line-number"},[e._v("69")]),s("br"),s("span",{staticClass:"line-number"},[e._v("70")]),s("br"),s("span",{staticClass:"line-number"},[e._v("71")]),s("br"),s("span",{staticClass:"line-number"},[e._v("72")]),s("br"),s("span",{staticClass:"line-number"},[e._v("73")]),s("br"),s("span",{staticClass:"line-number"},[e._v("74")]),s("br"),s("span",{staticClass:"line-number"},[e._v("75")]),s("br"),s("span",{staticClass:"line-number"},[e._v("76")]),s("br"),s("span",{staticClass:"line-number"},[e._v("77")]),s("br"),s("span",{staticClass:"line-number"},[e._v("78")]),s("br"),s("span",{staticClass:"line-number"},[e._v("79")]),s("br"),s("span",{staticClass:"line-number"},[e._v("80")]),s("br"),s("span",{staticClass:"line-number"},[e._v("81")]),s("br"),s("span",{staticClass:"line-number"},[e._v("82")]),s("br"),s("span",{staticClass:"line-number"},[e._v("83")]),s("br"),s("span",{staticClass:"line-number"},[e._v("84")]),s("br"),s("span",{staticClass:"line-number"},[e._v("85")]),s("br"),s("span",{staticClass:"line-number"},[e._v("86")]),s("br"),s("span",{staticClass:"line-number"},[e._v("87")]),s("br"),s("span",{staticClass:"line-number"},[e._v("88")]),s("br"),s("span",{staticClass:"line-number"},[e._v("89")]),s("br"),s("span",{staticClass:"line-number"},[e._v("90")]),s("br"),s("span",{staticClass:"line-number"},[e._v("91")]),s("br"),s("span",{staticClass:"line-number"},[e._v("92")]),s("br"),s("span",{staticClass:"line-number"},[e._v("93")]),s("br"),s("span",{staticClass:"line-number"},[e._v("94")]),s("br"),s("span",{staticClass:"line-number"},[e._v("95")]),s("br"),s("span",{staticClass:"line-number"},[e._v("96")]),s("br"),s("span",{staticClass:"line-number"},[e._v("97")]),s("br"),s("span",{staticClass:"line-number"},[e._v("98")]),s("br"),s("span",{staticClass:"line-number"},[e._v("99")]),s("br"),s("span",{staticClass:"line-number"},[e._v("100")]),s("br"),s("span",{staticClass:"line-number"},[e._v("101")]),s("br"),s("span",{staticClass:"line-number"},[e._v("102")]),s("br"),s("span",{staticClass:"line-number"},[e._v("103")]),s("br"),s("span",{staticClass:"line-number"},[e._v("104")]),s("br"),s("span",{staticClass:"line-number"},[e._v("105")]),s("br"),s("span",{staticClass:"line-number"},[e._v("106")]),s("br"),s("span",{staticClass:"line-number"},[e._v("107")]),s("br"),s("span",{staticClass:"line-number"},[e._v("108")]),s("br"),s("span",{staticClass:"line-number"},[e._v("109")]),s("br")])]),s("h2",{attrs:{id:"flags-affected"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#flags-affected"}},[e._v("#")]),e._v(" Flags affected")]),e._v(" "),s("p",[e._v("None.")]),e._v(" "),s("h2",{attrs:{id:"ia-32-architecture-compatibility"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ia-32-architecture-compatibility"}},[e._v("#")]),e._v(" IA-32 Architecture Compatibility")]),e._v(" "),s("p",[e._v("CPUID is not supported in early models of the Intel486 processor or in any IA-32 processor earlier than the Intel486 processor.")]),e._v(" "),s("h2",{attrs:{id:"exceptions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#exceptions"}},[e._v("#")]),e._v(" Exceptions")]),e._v(" "),s("p",[e._v("None.\nNOTE In earlier IA-32 processors that do not support the CPUID instruction, execution of the instruction results in an invalid opcode (#UD) exception being generated.")])])}),[],!1,null,null,null);t.default=r.exports}}]);