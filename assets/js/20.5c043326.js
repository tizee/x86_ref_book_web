(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{376:function(t,e,r){"use strict";r.r(e);var a=r(42),v=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"and"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#and"}},[t._v("#")]),t._v(" AND")]),t._v(" "),r("h2",{attrs:{id:"logical-and"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#logical-and"}},[t._v("#")]),t._v(" Logical AND")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("Opcode")]),t._v(" "),r("th",[t._v("Mnemonic")]),t._v(" "),r("th",[t._v("Description")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("24 ib")]),t._v(" "),r("td",[t._v("AND AL, imm8")]),t._v(" "),r("td",[t._v("AL AND imm8")])]),t._v(" "),r("tr",[r("td",[t._v("25 iw")]),t._v(" "),r("td",[t._v("AND AX, imm16")]),t._v(" "),r("td",[t._v("AX AND imm16")])]),t._v(" "),r("tr",[r("td",[t._v("25 id")]),t._v(" "),r("td",[t._v("AND EAX, imm32")]),t._v(" "),r("td",[t._v("EAX AND imm32")])]),t._v(" "),r("tr",[r("td",[t._v("80 /4 ib")]),t._v(" "),r("td",[t._v("AND r/m8, imm8")]),t._v(" "),r("td",[t._v("r/m8 AND imm8")])]),t._v(" "),r("tr",[r("td",[t._v("81 /4 iw")]),t._v(" "),r("td",[t._v("AND r/m16, imm16")]),t._v(" "),r("td",[t._v("r/m16 AND imm16")])]),t._v(" "),r("tr",[r("td",[t._v("81 /4 id")]),t._v(" "),r("td",[t._v("AND r/m32, imm32")]),t._v(" "),r("td",[t._v("r/m32 AND imm32")])]),t._v(" "),r("tr",[r("td",[t._v("83 /4 ib")]),t._v(" "),r("td",[t._v("AND r/m16, imm8")]),t._v(" "),r("td",[t._v("r/m16 AND imm8 (sign-extended)")])]),t._v(" "),r("tr",[r("td",[t._v("83 /4 ib")]),t._v(" "),r("td",[t._v("AND r/m32, imm8")]),t._v(" "),r("td",[t._v("r/m32 AND imm8 (sign-extended)")])]),t._v(" "),r("tr",[r("td",[t._v("20 /r")]),t._v(" "),r("td",[t._v("AND r/m8, r8")]),t._v(" "),r("td",[t._v("r/m8 AND r8")])]),t._v(" "),r("tr",[r("td",[t._v("21 /r")]),t._v(" "),r("td",[t._v("AND r/m16, r16")]),t._v(" "),r("td",[t._v("r/m16 AND r16")])]),t._v(" "),r("tr",[r("td",[t._v("21 /r")]),t._v(" "),r("td",[t._v("AND r/m32, r32")]),t._v(" "),r("td",[t._v("r/m32 AND r32")])]),t._v(" "),r("tr",[r("td",[t._v("22 /r")]),t._v(" "),r("td",[t._v("AND r8, r/m8")]),t._v(" "),r("td",[t._v("r8 AND r/m8")])]),t._v(" "),r("tr",[r("td",[t._v("23 /r")]),t._v(" "),r("td",[t._v("AND r16, r/m16")]),t._v(" "),r("td",[t._v("r16 AND r/m16")])]),t._v(" "),r("tr",[r("td",[t._v("23 /r")]),t._v(" "),r("td",[t._v("AND r32, r/m32")]),t._v(" "),r("td",[t._v("r32 AND r/m32")])])])]),t._v(" "),r("h2",{attrs:{id:"description"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#description"}},[t._v("#")]),t._v(" Description")]),t._v(" "),r("p",[t._v("Performs a bitwise AND operation on the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location.")]),t._v(" "),r("p",[t._v("(However, two memory operands cannot be used in one instruction.) Each bit of the result is set to 1 if both corresponding bits of the first and second operands are 1; otherwise, it is set to 0.")]),t._v(" "),r("p",[t._v("This instruction can be used with a LOCK prefix to allow the it to be executed atomically.")]),t._v(" "),r("h2",{attrs:{id:"operation"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#operation"}},[t._v("#")]),t._v(" Operation")]),t._v(" "),r("div",{staticClass:"language-c line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-c"}},[r("code",[t._v("Destination "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Destination "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" Source"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br")])]),r("h2",{attrs:{id:"flags-affected"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#flags-affected"}},[t._v("#")]),t._v(" Flags affected")]),t._v(" "),r("p",[t._v("The OF and CF flags are cleared; the SF, ZF, and PF flags are set according to the result. The state of the AF flag is undefined.")]),t._v(" "),r("h2",{attrs:{id:"protected-mode-exceptions"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#protected-mode-exceptions"}},[t._v("#")]),t._v(" Protected Mode Exceptions")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[r("a",{attrs:{href:""}})]),t._v(" "),r("th")])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("#GP(0)")]),t._v(" "),r("td",[t._v("If the destination operand points to a non-writable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.")])]),t._v(" "),r("tr",[r("td",[t._v("#GP(0)")]),t._v(" "),r("td",[t._v("If the destination operand points to a non-writable segment. If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register contains a null segment selector.")])]),t._v(" "),r("tr",[r("td",[t._v("#SS(0)")]),t._v(" "),r("td",[t._v("If a memory operand effective address is outside the SS segment limit.")])]),t._v(" "),r("tr",[r("td",[t._v("#PF(fault-code)")]),t._v(" "),r("td",[t._v("If a page fault occurs.")])])])]),t._v(" "),r("h2",{attrs:{id:"real-address-mode-exceptions"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#real-address-mode-exceptions"}},[t._v("#")]),t._v(" Real-Address Mode Exceptions")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[r("a",{attrs:{href:""}})]),t._v(" "),r("th")])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("#GP")]),t._v(" "),r("td",[t._v("If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.")])]),t._v(" "),r("tr",[r("td",[t._v("#GP")]),t._v(" "),r("td",[t._v("If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.")])])])]),t._v(" "),r("h2",{attrs:{id:"virtual-8086-mode-exceptions"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#virtual-8086-mode-exceptions"}},[t._v("#")]),t._v(" Virtual-8086 Mode Exceptions")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[r("a",{attrs:{href:""}})]),t._v(" "),r("th")])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("#GP(0)")]),t._v(" "),r("td",[t._v("If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.")])]),t._v(" "),r("tr",[r("td",[t._v("#GP(0)")]),t._v(" "),r("td",[t._v("If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.")])]),t._v(" "),r("tr",[r("td",[t._v("#SS(0)")]),t._v(" "),r("td",[t._v("If a memory operand effective address is outside the SS segment limit.")])]),t._v(" "),r("tr",[r("td",[t._v("#PF(fault-code)")]),t._v(" "),r("td",[t._v("If a page fault occurs.")])])])]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("Instruction")]),t._v(" "),r("th",[t._v("Latency")]),t._v(" "),r("th",[t._v("Throughput")]),t._v(" "),r("th",[t._v("Execution Unit")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("CPUID")]),t._v(" "),r("td",[t._v("0F3n/0F2n")]),t._v(" "),r("td",[t._v("0F3n/0F2n")]),t._v(" "),r("td",[t._v("0F2n")])]),t._v(" "),r("tr",[r("td",[t._v("AND")]),t._v(" "),r("td",[t._v("1/0.5")]),t._v(" "),r("td",[t._v("0.5/0.5")]),t._v(" "),r("td",[t._v("ALU")])])])])])}),[],!1,null,null,null);e.default=v.exports}}]);