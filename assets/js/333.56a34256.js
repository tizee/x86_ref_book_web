(window.webpackJsonp=window.webpackJsonp||[]).push([[333],{687:function(t,a,e){"use strict";e.r(a);var r=e(42),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"xadd"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#xadd"}},[t._v("#")]),t._v(" XADD")]),t._v(" "),e("h2",{attrs:{id:"exchange-and-add"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#exchange-and-add"}},[t._v("#")]),t._v(" Exchange and Add")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("Opcode")]),t._v(" "),e("th",[t._v("Mnemonic")]),t._v(" "),e("th",[t._v("Description")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("0F C0 /r")]),t._v(" "),e("td",[t._v("XADD r/m8, r8")]),t._v(" "),e("td",[t._v("Exchange r8 and r/m8; load sum into r/m8.")])]),t._v(" "),e("tr",[e("td",[t._v("0F C1 /r")]),t._v(" "),e("td",[t._v("XADD r/m16, r16")]),t._v(" "),e("td",[t._v("Exchange r16 and r/m16; load sum into r/m16.")])]),t._v(" "),e("tr",[e("td",[t._v("0F C1 /r")]),t._v(" "),e("td",[t._v("XADD r/m32, r32")]),t._v(" "),e("td",[t._v("Exchange r32 and r/m32; load sum into r/m32.")])])])]),t._v(" "),e("h2",{attrs:{id:"description"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#description"}},[t._v("#")]),t._v(" Description")]),t._v(" "),e("p",[t._v("Exchanges the first operand (destination operand) with the second operand (source operand), then loads the sum of the two values into the destination operand. The destination operand can be a register or a memory location; the source operand is a register.")]),t._v(" "),e("p",[t._v("This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.")]),t._v(" "),e("h2",{attrs:{id:"operation"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#operation"}},[t._v("#")]),t._v(" Operation")]),t._v(" "),e("div",{staticClass:"language-c line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[t._v("Temporary "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Source "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" Destination"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nSource "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Destination"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nDestination "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Temporary"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br")])]),e("h2",{attrs:{id:"flags-affected"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flags-affected"}},[t._v("#")]),t._v(" Flags affected")]),t._v(" "),e("p",[t._v("The CF, PF, AF, SF, ZF, and OF flags are set according to the result of the addition, which is stored in the destination operand.")]),t._v(" "),e("h2",{attrs:{id:"ia-32-architecture-compatibility"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ia-32-architecture-compatibility"}},[t._v("#")]),t._v(" IA-32 Architecture Compatibility")]),t._v(" "),e("p",[t._v("IA-32 processors earlier than the Intel486 processor do not recognize this instruction. If this instruction is used, you should provide an equivalent code sequence that runs on earlier processors.")])])}),[],!1,null,null,null);a.default=s.exports}}]);