(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{463:function(t,e,o){"use strict";o.r(e);var a=o(42),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h1",{attrs:{id:"fldcw"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#fldcw"}},[t._v("#")]),t._v(" FLDCW")]),t._v(" "),o("h2",{attrs:{id:"load-x87-fpu-control-word"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#load-x87-fpu-control-word"}},[t._v("#")]),t._v(" Load x87 FPU Control Word")]),t._v(" "),o("table",[o("thead",[o("tr",[o("th",[t._v("Opcode")]),t._v(" "),o("th",[t._v("Mnemonic")]),t._v(" "),o("th",[t._v("Description")])])]),t._v(" "),o("tbody",[o("tr",[o("td",[t._v("D9 /5")]),t._v(" "),o("td",[t._v("FLDCW m2byte")]),t._v(" "),o("td",[t._v("Load FPU control word from m2byte.")])])])]),t._v(" "),o("h2",{attrs:{id:"description"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#description"}},[t._v("#")]),t._v(" Description")]),t._v(" "),o("p",[t._v("Loads the 16-bit source operand into the FPU control word. The source operand is a memory location. This instruction is typically used to establish or change the FPU's mode of operation.")]),t._v(" "),o("p",[t._v('If one or more exception flags are set in the FPU status word prior to loading a new FPU control word and the new control word unmasks one or more of those exceptions, a floating-point exception will be generated upon execution of the next floating-point instruction (except for the no-wait floating-point instructions, see the section titled "Software Exception Handling" in Chapter 8 of the IA-32 Intel Architecture Software Developer\'s Manual, Volume 1). To avoid raising exceptions when changing FPU operating modes, clear any pending exceptions (using the FCLEX or FNCLEX instruction) before loading the new control word.')]),t._v(" "),o("h2",{attrs:{id:"operation"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#operation"}},[t._v("#")]),t._v(" Operation")]),t._v(" "),o("div",{staticClass:"language-c line-numbers-mode"},[o("pre",{pre:!0,attrs:{class:"language-c"}},[o("code",[t._v("FPUControlWord "),o("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Source"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])]),t._v(" "),o("div",{staticClass:"line-numbers-wrapper"},[o("span",{staticClass:"line-number"},[t._v("1")]),o("br"),o("span",{staticClass:"line-number"},[t._v("2")]),o("br")])]),o("h2",{attrs:{id:"fpu-flags-affected"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#fpu-flags-affected"}},[t._v("#")]),t._v(" FPU flags affected")]),t._v(" "),o("p",[t._v("C0, C1, C2, C3 undefined.")]),t._v(" "),o("h2",{attrs:{id:"floating-point-exceptions"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#floating-point-exceptions"}},[t._v("#")]),t._v(" Floating-Point Exceptions")]),t._v(" "),o("p",[t._v('None; however, this operation might unmask a pending exception in the FPU status word. That exception is then generated upon execution of the next "waiting" floating-point instruction.')]),t._v(" "),o("h2",{attrs:{id:"protected-mode-exceptions"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#protected-mode-exceptions"}},[t._v("#")]),t._v(" Protected Mode Exceptions")]),t._v(" "),o("table",[o("thead",[o("tr",[o("th",[o("a",{attrs:{href:""}})]),t._v(" "),o("th")])]),t._v(" "),o("tbody",[o("tr",[o("td",[t._v("#GP(0)")]),t._v(" "),o("td",[t._v("If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.")])]),t._v(" "),o("tr",[o("td",[t._v("#GP(0)")]),t._v(" "),o("td",[t._v("If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.")])]),t._v(" "),o("tr",[o("td",[t._v("#SS(0)")]),t._v(" "),o("td",[t._v("If a memory operand effective address is outside the SS segment limit.")])]),t._v(" "),o("tr",[o("td",[t._v("#NM")]),t._v(" "),o("td",[t._v("EM or TS in CR0 is set.")])]),t._v(" "),o("tr",[o("td",[t._v("#PF(fault-code)")]),t._v(" "),o("td",[t._v("If a page fault occurs.")])])])]),t._v(" "),o("h2",{attrs:{id:"real-address-mode-exceptions"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#real-address-mode-exceptions"}},[t._v("#")]),t._v(" Real-Address Mode Exceptions")]),t._v(" "),o("table",[o("thead",[o("tr",[o("th",[o("a",{attrs:{href:""}})]),t._v(" "),o("th")])]),t._v(" "),o("tbody",[o("tr",[o("td",[t._v("#GP")]),t._v(" "),o("td",[t._v("If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.")])]),t._v(" "),o("tr",[o("td",[t._v("#GP")]),t._v(" "),o("td",[t._v("If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.")])]),t._v(" "),o("tr",[o("td",[t._v("#SS")]),t._v(" "),o("td",[t._v("If a memory operand effective address is outside the SS segment limit.")])])])]),t._v(" "),o("h2",{attrs:{id:"virtual-8086-mode-exceptions"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#virtual-8086-mode-exceptions"}},[t._v("#")]),t._v(" Virtual-8086 Mode Exceptions")]),t._v(" "),o("table",[o("thead",[o("tr",[o("th",[o("a",{attrs:{href:""}})]),t._v(" "),o("th")])]),t._v(" "),o("tbody",[o("tr",[o("td",[t._v("#GP(0)")]),t._v(" "),o("td",[t._v("If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.")])]),t._v(" "),o("tr",[o("td",[t._v("#GP(0)")]),t._v(" "),o("td",[t._v("If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.")])]),t._v(" "),o("tr",[o("td",[t._v("#SS(0)")]),t._v(" "),o("td",[t._v("If a memory operand effective address is outside the SS segment limit.")])]),t._v(" "),o("tr",[o("td",[t._v("#NM")]),t._v(" "),o("td",[t._v("EM or TS in CR0 is set.")])]),t._v(" "),o("tr",[o("td",[t._v("#PF(fault-code)")]),t._v(" "),o("td",[t._v("If a page fault occurs.")])])])])])}),[],!1,null,null,null);e.default=r.exports}}]);