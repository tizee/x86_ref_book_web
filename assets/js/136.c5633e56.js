(window.webpackJsonp=window.webpackJsonp||[]).push([[136],{490:function(e,t,n){"use strict";n.r(t);var a=n(42),i=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"fxsave"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#fxsave"}},[e._v("#")]),e._v(" FXSAVE")]),e._v(" "),n("h2",{attrs:{id:"save-x87-fpu-mmx-technology-sse-and-sse2-state"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#save-x87-fpu-mmx-technology-sse-and-sse2-state"}},[e._v("#")]),e._v(" Save x87 FPU, MMX Technology, SSE, and SSE2 State")]),e._v(" "),n("table",[n("thead",[n("tr",[n("th",[e._v("Opcode")]),e._v(" "),n("th",[e._v("Mnemonic")]),e._v(" "),n("th",[e._v("Description")])])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("0F AE /0")]),e._v(" "),n("td",[e._v("FXSAVE m512byte")]),e._v(" "),n("td",[e._v("Save the x87 FPU, MMX technology, XMM, and MXCSR register state to m512byte.")])])])]),e._v(" "),n("table",[n("thead",[n("tr",[n("th",[e._v("Description")]),e._v(" "),n("th",[e._v("Bit #")]),e._v(" "),n("th",[e._v("Description")]),e._v(" "),n("th",[e._v("R7")]),e._v(" "),n("th",[e._v("R6")]),e._v(" "),n("th",[e._v("R5")]),e._v(" "),n("th",[e._v("R4")]),e._v(" "),n("th",[e._v("R3")]),e._v(" "),n("th",[e._v("R2")]),e._v(" "),n("th",[e._v("R1")]),e._v(" "),n("th",[e._v("R0")]),e._v(" "),n("th",[e._v("R7")]),e._v(" "),n("th",[e._v("R6")]),e._v(" "),n("th",[e._v("R5")]),e._v(" "),n("th",[e._v("R4")]),e._v(" "),n("th",[e._v("R3")]),e._v(" "),n("th",[e._v("R2")]),e._v(" "),n("th",[e._v("R1")]),e._v(" "),n("th",[e._v("R0")]),e._v(" "),n("th",[e._v("Exponent all 1's")]),e._v(" "),n("th",[e._v("Exponent all 0's")]),e._v(" "),n("th",[e._v("Fraction all 0's")]),e._v(" "),n("th",[e._v("J and M bits")]),e._v(" "),n("th",[e._v("FTW valid bit")]),e._v(" "),n("th",[e._v("x87 FTW")])])]),e._v(" "),n("tbody",[n("tr",[n("td"),e._v(" "),n("td"),e._v(" "),n("td"),e._v(" "),n("td"),e._v(" "),n("td"),e._v(" "),n("td"),e._v(" "),n("td"),e._v(" "),n("td"),e._v(" "),n("td"),e._v(" "),n("td"),e._v(" "),n("td"),e._v(" "),n("td"),e._v(" "),n("td"),e._v(" "),n("td"),e._v(" "),n("td"),e._v(" "),n("td"),e._v(" "),n("td"),e._v(" "),n("td"),e._v(" "),n("td"),e._v(" "),n("td"),e._v(" "),n("td"),e._v(" "),n("td"),e._v(" "),n("td"),e._v(" "),n("td"),e._v(" "),n("td")])])]),e._v(" "),n("p",[e._v("Saves the current state of the x87 FPU, MMX technology, XMM, and MXCSR registers to a 512-byte memory location specified in the destination operand. The following table shows the layout of the state information in memory.")]),e._v(" "),n("p",[e._v("Layout of FXSAVE and FXRSTOR Memory Region\nBit #Description\n0-1FCW\n2-3FSW\n4FTW\n5Reserved\n6-7FOP\n8-11FPU IP\n12-13CS\n14-15Reserved\n16-19FPU DP\n20-21DS\n22-23Reserved\n24-27MXCSR\n28-31MXCSR_MASK\n32-41ST0/MM0\n42-47Reserved\n48-57ST1/MM1\n58-63Reserved\n64-73ST2/MM2\n74-79Reserved\n80-89ST3/MM3\n90-95Reserved\n96-105ST4/MM4\n106-111Reserved\n112-121ST5/MM5\n122-127Reserved\n128-137ST6/MM6\n138-143Reserved\n144-153ST7/MM7\n154-159Reserved\n160-175XMM0\n176-191XMM1\n192-207XMM2\n208-223XMM3\n224-239XMM4\n240-255XMM5\n256-271XMM6\n272-287XMM7\n288-512Reserved")]),e._v(" "),n("p",[e._v("The destination operand contains the first byte of the memory image, and it must be aligned on a 16-byte boundary. A misaligned destination operand will result in a general-protection (#GP) exception being generated (or in some cases, an alignment check exception [#AC]).\nThe FXSAVE instruction is used when an operating system needs to perform a context switch or when an exception handler needs to save and examine the current state of the x87 FPU, MMX technology, and/or XMM and MXCSR registers.\nThe fields in the table above are as follows:")]),e._v(" "),n("p",[e._v("FCW\nx87 FPU Control Word (16 bits). See Figure 8-6 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for the layout of the x87 FPU control word.\nFSW\nx87 FPU Status Word (16 bits). See Figure 8-4 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for the layout of the x87 FPU status word.\nFTW\nx87 FPU Tag Word (8 bits). The tag information saved here is abridged, as described in the following paragraphs. See Figure 8-7 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for the layout of the x87 FPU tag word.\nFOP\nx87 FPU Opcode (16 bits). The lower 11 bits of this field contain the opcode, upper 5 bits are reserved. See Figure 8-8 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for the layout of the x87 FPU opcode field.\nFPU\nIP x87 FPU Instruction Pointer Offset (32 bits). The contents of this field differ depending on the current addressing mode (32-bit or 16-bit) of the processor when the FXSAVE instruction was executed: 32-bit mode -> 32-bit IP offset, 16-bit mode -> low 16 bits are IP offset with the high 16 bits being reserved. See \"x87 FPU Instruction and Operand (Data) Pointers\" in Chapter 8 of the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for a description of the x87 FPU instruction pointer.\nCS\nx87 FPU Instruction Pointer Selector (16 bits).\nFPU\nDP x87 FPU Instruction Operand (Data) Pointer Offset (32 bits). The contents of this field differ depending on the current addressing mode (32-bit or 16- bit) of the processor when the FXSAVE instruction was executed: 32-bit mode -> 32-bit IP offset, 16-bit mode -> low 16 bits are IP offset with the high 16 bits being reserved. See \"x87 FPU Instruction and Operand (Data) Pointers\" in Chapter 8 of the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for a description of the x87 FPU operand pointer.\nDS\nx87 FPU Instruction Operand (Data) Pointer Selector (16 bits).\nMXCSR\nMXCSR Register State (32 bits). See Figure 10-3 in the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for the layout of the MXCSR register. If the OSFXSR bit in control register CR4 is not set, the FXSAVE instruction may not save this register. This behavior is implementation dependent.\nMXCSR_MASK\nMXCSR_MASK (32 bits). This mask can be used to adjust values written to the MXCSR register, ensuring that reserved bits are set to 0. Set the mask bits and flags in MXCSR to the mode of operation desired for SSE and SSE2 SIMD floating-point instructions. See \"Guidelines for Writing to the MXCSR Register\" in Chapter 11 of the IA-32 Intel Architecture Software Developer's Manual, Volume 1, for instructions for how to determine and use the MXCSR_MASK value.\nST0/MM0 through ST7/MM7\nx87 FPU or MMX technology registers. These 80-bit fields contain the x87 FPU data registers or the MMX technology registers, depending on the state of the processor prior to the execution of the FXSAVE instruction. If the processor had been executing x87 FPU instruction prior to the FXSAVE instruction, the x87 FPU data registers are saved; if it had been executing MMX instructions (or SSE or SSE2 instructions that operated on the MMX technology registers), the MMX technology registers are saved. When the MMX technology registers are saved, the high 16 bits of the field are reserved.\nXMM0 through XMM7\nXMM registers (128 bits per field). If the OSFXSR bit in control register CR4 is not set, the FXSAVE instruction may not save these registers. This behavior is implementation dependent.")]),e._v(" "),n("p",[e._v("The FXSAVE instruction saves an abridged version of the x87 FPU tag word in the FTW field (unlike the FSAVE instruction, which saves the complete tag word). The tag information is saved in physical register order (R0 through R7), rather than in top-of-stack (TOS) order. With the FXSAVE instruction, however, only a single bit (1 for valid or 0 for empty) is saved for each tag. For example, assume that the tag word is currently set as follows:")]),e._v(" "),n("p",[e._v("R7R6R5R4R3R2R1R0\n[body]11xxxxxx11111111[/body]")]),e._v(" "),n("p",[e._v('Here, 11B indicates empty stack elements and "xx" indicates valid (00B), zero (01B), or special (10B).')]),e._v(" "),n("p",[e._v("For this example, the FXSAVE instruction saves only the following 8 bits of information:")]),e._v(" "),n("p",[e._v("R7R6R5R4R3R2R1R0\n[body]01110000[/body]")]),e._v(" "),n("p",[e._v("Here, a 1 is saved for any valid, zero, or special tag, and a 0 is saved for any empty tag.")]),e._v(" "),n("p",[e._v("The operation of the FXSAVE instruction differs from that of the FSAVE instruction, the as follows:")]),e._v(" "),n("p",[e._v('FXSAVE instruction does not check for pending unmasked floating-point exceptions. (The FXSAVE operation in this regard is similar to the operation of the FNSAVE instruction).\nAfter the FXSAVE instruction has saved the state of the x87 FPU, MMX technology, XMM, and MXCSR registers, the processor retains the contents of the registers. Because of this behavior, the FXSAVE instruction cannot be used by an application program to pass a "clean" x87 FPU state to a procedure, since it retains the current state. To clean the x87 FPU state, an application must explicitly execute an FINIT instruction after an FXSAVE instruction to reinitialize the x87 FPU state.\nThe format of the memory image saved with the FXSAVE instruction is the same regardless of the current addressing mode (32-bit or 16-bit) and operating mode (protected, real address, or system management). This behavior differs from the FSAVE instructions, where the memory image format is different depending on the addressing mode and operating mode. Because of the different image formats, the memory image saved with the FXSAVE instruction cannot be restored correctly with the FRSTOR instruction, and likewise the state saved with the FSAVE instruction cannot be restored correctly with the FXRSTOR instruction.')]),e._v(" "),n("p",[e._v("Note that The FSAVE format for FTW can be recreated from the FTW valid bits and the stored 80-bit FP data (assuming the stored data was not the contents of MMX technology registers) using the following table:")]),e._v(" "),n("p",[e._v("Recreating FSAVE Format\nExponent all 1'sExponent all 0'sFraction all 0'sJ and M bitsFTW valid bitx87 FTW\n0000x1Special 10\n0001x1Valid 00\n001001Special 10\n001101Valid 00\n0100x1Special 10\n0101x1Special 10\n011001Zero 01\n011101Special 10\n1001x1Special 10\n1001x1Special 10\n101001Special 10\n101101Special 10\nAny legalAny legalAny legalAny legal0Empty 11")]),e._v(" "),n("p",[e._v('The J-bit is defined to be the 1-bit binary integer to the left of the decimal place in the mantissa.\nThe M-bit is defined to be the most significant bit of the fractional portion of the mantissa (i.e., the bit immediately to the right of the decimal place).\nWhen the M-bit is the most significant bit of the fractional portion of the mantissa, it must be 0 if the fraction is all 0\'s.\n|0-1|FCW|2-3|FSW|4|FTW|5|Reserved|6-7|FOP|8-11|FPU IP|12-13|CS|14-15|Reserved|16-19|FPU DP|20-21|DS|22-23|Reserved|24-27|MXCSR|28-31|MXCSR_MASK|32-41|ST0/MM0|42-47|Reserved|48-57|ST1/MM1|58-63|Reserved|64-73|ST2/MM2|74-79|Reserved|80-89|ST3/MM3|90-95|Reserved|96-105|ST4/MM4|106-111|Reserved|112-121|ST5/MM5|122-127|Reserved|128-137|ST6/MM6|138-143|Reserved|144-153|ST7/MM7|154-159|Reserved|160-175|XMM0|176-191|XMM1|192-207|XMM2|208-223|XMM3|224-239|XMM4|240-255|XMM5|256-271|XMM6|272-287|XMM7|288-512|Reserved|[body]11|xx|xx|xx|11|11|11|11[/body]|Here, 11B indicates empty stack elements and "xx" indicates valid (00B), zero (01B), or special (10B).|[body]0|1|1|1|0|0|0|0[/body]|Here, a 1 is saved for any valid, zero, or special tag, and a 0 is saved for any empty tag.|0|0|0|0x|1|Special 10|0|0|0|1x|1|Valid 00|0|0|1|00|1|Special 10|0|0|1|10|1|Valid 00|0|1|0|0x|1|Special 10|0|1|0|1x|1|Special 10|0|1|1|00|1|Zero 01|0|1|1|10|1|Special 10|1|0|0|1x|1|Special 10|1|0|0|1x|1|Special 10|1|0|1|00|1|Special 10|1|0|1|10|1|Special 10|Any legal|Any legal|Any legal|Any legal|0|Empty 11|\n|\n|0-1|FCW|\n|2-3|FSW|\n|4|FTW|\n|5|Reserved|\n|6-7|FOP|\n|8-11|FPU IP|\n|12-13|CS|\n|14-15|Reserved|\n|16-19|FPU DP|\n|20-21|DS|\n|22-23|Reserved|\n|24-27|MXCSR|\n|28-31|MXCSR_MASK|\n|32-41|ST0/MM0|\n|42-47|Reserved|\n|48-57|ST1/MM1|\n|58-63|Reserved|\n|64-73|ST2/MM2|\n|74-79|Reserved|\n|80-89|ST3/MM3|\n|90-95|Reserved|\n|96-105|ST4/MM4|\n|106-111|Reserved|\n|112-121|ST5/MM5|\n|122-127|Reserved|\n|128-137|ST6/MM6|\n|138-143|Reserved|\n|144-153|ST7/MM7|\n|154-159|Reserved|\n|160-175|XMM0|\n|176-191|XMM1|\n|192-207|XMM2|\n|208-223|XMM3|\n|224-239|XMM4|\n|240-255|XMM5|\n|256-271|XMM6|\n|272-287|XMM7|\n|288-512|Reserved|\n|\n|[body]11|xx|xx|xx|11|11|11|11[/body]|\n|Here, 11B indicates empty stack elements and "xx" indicates valid (00B), zero (01B), or special (10B).|\n|\n|[body]0|1|1|1|0|0|0|0[/body]|\n|Here, a 1 is saved for any valid, zero, or special tag, and a 0 is saved for any empty tag.|\n|\n|0|0|0|0x|1|Special 10|\n|0|0|0|1x|1|Valid 00|\n|0|0|1|00|1|Special 10|\n|0|0|1|10|1|Valid 00|\n|0|1|0|0x|1|Special 10|\n|0|1|0|1x|1|Special 10|\n|0|1|1|00|1|Zero 01|\n|0|1|1|10|1|Special 10|\n|1|0|0|1x|1|Special 10|\n|1|0|0|1x|1|Special 10|\n|1|0|1|00|1|Special 10|\n|1|0|1|10|1|Special 10|\n|Any legal|Any legal|Any legal|Any legal|0|Empty 11|')]),e._v(" "),n("h2",{attrs:{id:"operation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#operation"}},[e._v("#")]),e._v(" Operation")]),e._v(" "),n("div",{staticClass:"language-c line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-c"}},[n("code",[e._v("Destination "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("Save")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("x87 FPU"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" MMX"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" XMM7"),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("-")]),e._v("XMM0"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" MXCSR"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br")])]),n("h2",{attrs:{id:"real-address-mode-exceptions"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#real-address-mode-exceptions"}},[e._v("#")]),e._v(" Real-Address Mode Exceptions")]),e._v(" "),n("table",[n("thead",[n("tr",[n("th",[n("a",{attrs:{href:""}})]),e._v(" "),n("th")])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("#GP(0)")]),e._v(" "),n("td",[e._v("If a memory operand is not aligned on a 16-byte boundary, regardless of segment. If any part of the operand lies outside the effective address space from 0 to FFFFH.")])]),e._v(" "),n("tr",[n("td",[e._v("#GP(0)")]),e._v(" "),n("td",[e._v("If a memory operand is not aligned on a 16-byte boundary, regardless of segment. If any part of the operand lies outside the effective address space from 0 to FFFFH.")])]),e._v(" "),n("tr",[n("td",[e._v("#NM")]),e._v(" "),n("td",[e._v("If TS in CR0 is set.")])])])]),e._v(" "),n("table",[n("thead",[n("tr",[n("th",[e._v("Instruction")]),e._v(" "),n("th",[e._v("Latency")]),e._v(" "),n("th",[e._v("Throughput")]),e._v(" "),n("th",[e._v("Execution Unit")])])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("CPUID")]),e._v(" "),n("td",[e._v("0F3n/0F2n/069n")]),e._v(" "),n("td",[e._v("0F3n/0F2n/069n")]),e._v(" "),n("td",[e._v("0F2n")])]),e._v(" "),n("tr",[n("td",[e._v("FXSAVE")]),e._v(" "),n("td",[e._v("100")]),e._v(" "),n("td",[e._v("-")]),e._v(" "),n("td",[e._v("-")])])])])])}),[],!1,null,null,null);t.default=i.exports}}]);