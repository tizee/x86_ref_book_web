(window.webpackJsonp=window.webpackJsonp||[]).push([[157],{510:function(t,e,s){"use strict";s.r(e);var a=s(42),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"lar"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#lar"}},[t._v("#")]),t._v(" LAR")]),t._v(" "),s("h2",{attrs:{id:"load-access-rights-byte"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#load-access-rights-byte"}},[t._v("#")]),t._v(" Load Access Rights Byte")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("Opcode")]),t._v(" "),s("th",[t._v("Mnemonic")]),t._v(" "),s("th",[t._v("Description")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("0F 02 /r")]),t._v(" "),s("td",[t._v("LAR r16,r/m16")]),t._v(" "),s("td",[t._v("r16 = r/m16 masked by FF00H.")])]),t._v(" "),s("tr",[s("td",[t._v("0F 02 /r")]),t._v(" "),s("td",[t._v("LAR r32,r/m32")]),t._v(" "),s("td",[t._v("r32 = r/m32 masked by 00FxFF00H.")])])])]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("Description")]),t._v(" "),s("th",[t._v("Type")]),t._v(" "),s("th",[t._v("Name")]),t._v(" "),s("th",[t._v("Valid")])])]),t._v(" "),s("tbody",[s("tr",[s("td"),t._v(" "),s("td"),t._v(" "),s("td"),t._v(" "),s("td")])])]),t._v(" "),s("p",[t._v("Loads the access rights from the segment descriptor specified by the second operand (source operand) into the first operand (destination operand) and sets the ZF flag in the EFLAGS register. The source operand (which can be a register or a memory location) contains the segment selector for the segment descriptor being accessed. The destination operand is a general-purpose register.\nThe processor performs access checks as part of the loading process. Once loaded in the destination register, software can perform additional checks on the access rights information.\nWhen the operand size is 32 bits, the access rights for a segment descriptor include the type and DPL fields and the S, P, AVL, D/B, and G flags, all of which are located in the second doubleword (bytes 4 through 7) of the segment descriptor. The doubleword is masked by 00FXFF00H before it is loaded into the destination operand. When the operand size is 16 bits, the access rights include the type and DPL fields. Here, the two lower-order bytes of the doubleword are masked by FF00H before being loaded into the destination operand.\nThis instruction performs the following checks before it loads the access rights in the destination register:")]),t._v(" "),s("p",[t._v("Checks that the segment selector is not null.\nChecks that the segment selector points to a descriptor that is within the limits of the GDT or LDT being accessed - Checks that the descriptor type is valid for this instruction. All code and data segment descriptors are valid for (can be accessed with) the LAR instruction. The valid system segment and gate descriptor types are given in Table 3-53.\nIf the segment is not a conforming code segment, it checks that the specified segment descriptor is visible at the CPL (that is, if the CPL and the RPL of the segment selector are less than or equal to the DPL of the segment selector).")]),t._v(" "),s("p",[t._v("If the segment descriptor cannot be accessed or is an invalid type for the instruction, the ZF flag is cleared and no access rights are loaded in the destination operand.\nThe LAR instruction can only be executed in protected mode.")]),t._v(" "),s("p",[t._v("Segment and Gate Types\nTypeNameValid\n0ReservedNo\n1Available 16-bit TSSYes\n2LDTYes\n3Busy 16-bit TSSYes\n416-bit call gateYes\n516-bit/32-bit task gateYes\n616-bit interrupt gateNo\n716-bit trap gateNo\n8ReservedNo\n9Available 32-bit TSSYes\nAReservedNo\nBBusy 32-bit TSSYes\nC32-bit call gateYes\nDReservedNo\nE32-bit interrupt gateNo\nF32-bit trap gateNo")]),t._v(" "),s("p",[t._v("|0|Reserved|No|1|Available 16-bit TSS|Yes|2|LDT|Yes|3|Busy 16-bit TSS|Yes|4|16-bit call gate|Yes|5|16-bit/32-bit task gate|Yes|6|16-bit interrupt gate|No|7|16-bit trap gate|No|8|Reserved|No|9|Available 32-bit TSS|Yes|A|Reserved|No|B|Busy 32-bit TSS|Yes|C|32-bit call gate|Yes|D|Reserved|No|E|32-bit interrupt gate|No|F|32-bit trap gate|No|\n|\n|0|Reserved|No|\n|1|Available 16-bit TSS|Yes|\n|2|LDT|Yes|\n|3|Busy 16-bit TSS|Yes|\n|4|16-bit call gate|Yes|\n|5|16-bit/32-bit task gate|Yes|\n|6|16-bit interrupt gate|No|\n|7|16-bit trap gate|No|\n|8|Reserved|No|\n|9|Available 32-bit TSS|Yes|\n|A|Reserved|No|\n|B|Busy 32-bit TSS|Yes|\n|C|32-bit call gate|Yes|\n|D|Reserved|No|\n|E|32-bit interrupt gate|No|\n|F|32-bit trap gate|No|")]),t._v(" "),s("h2",{attrs:{id:"operation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#operation"}},[t._v("#")]),t._v(" Operation")]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Source"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Offset "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" DescriptorTableLimit"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" ZF "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nSegmentDescriptor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ReadSegmentDescriptor")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("SegmentDescriptor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Type "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" TypeConformingCodeSegment "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" CPL "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" DPL "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" RPL "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" DPL "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("CheckInstructionValidity")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("SegmentDescriptor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Type"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*Segment type is not valid for instruction*/")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" ZF "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//Source: segment relative offset")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("OperandSize "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("32")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" Destination "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Source "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0xF")]),t._v("XFF00"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//X: undefined?")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" Destination "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Source "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0xFF00")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//OperandSize == 16")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br")])]),s("h2",{attrs:{id:"flags-affected"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#flags-affected"}},[t._v("#")]),t._v(" Flags affected")]),t._v(" "),s("p",[t._v("The ZF flag is set to 1 if the access rights are loaded successfully; otherwise, it is set to 0.")]),t._v(" "),s("h2",{attrs:{id:"protected-mode-exceptions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#protected-mode-exceptions"}},[t._v("#")]),t._v(" Protected Mode Exceptions")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[s("a",{attrs:{href:""}})]),t._v(" "),s("th")])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("#GP(0)")]),t._v(" "),s("td",[t._v("If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.")])]),t._v(" "),s("tr",[s("td",[t._v("#GP(0)")]),t._v(" "),s("td",[t._v("If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit. If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.")])]),t._v(" "),s("tr",[s("td",[t._v("#SS(0)")]),t._v(" "),s("td",[t._v("If a memory operand effective address is outside the SS segment limit.")])]),t._v(" "),s("tr",[s("td",[t._v("#PF(fault-code)")]),t._v(" "),s("td",[t._v("If a page fault occurs.")])])])]),t._v(" "),s("h2",{attrs:{id:"real-address-mode-exceptions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#real-address-mode-exceptions"}},[t._v("#")]),t._v(" Real-Address Mode Exceptions")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[s("a",{attrs:{href:""}})]),t._v(" "),s("th")])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("#UD")]),t._v(" "),s("td",[t._v("The LAR instruction is not recognized in real-address mode.")])])])]),t._v(" "),s("h2",{attrs:{id:"virtual-8086-mode-exceptions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#virtual-8086-mode-exceptions"}},[t._v("#")]),t._v(" Virtual-8086 Mode Exceptions")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[s("a",{attrs:{href:""}})]),t._v(" "),s("th")])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("#UD")]),t._v(" "),s("td",[t._v("The LAR instruction cannot be executed in virtual-8086 mode.")])])])])])}),[],!1,null,null,null);e.default=r.exports}}]);