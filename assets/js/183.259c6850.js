(window.webpackJsonp=window.webpackJsonp||[]).push([[183],{537:function(e,t,a){"use strict";a.r(t);var r=a(42),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"monitor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#monitor"}},[e._v("#")]),e._v(" MONITOR")]),e._v(" "),a("h2",{attrs:{id:"setup-monitor-address"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setup-monitor-address"}},[e._v("#")]),e._v(" Setup Monitor Address")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("Opcode")]),e._v(" "),a("th",[e._v("Mnemonic")]),e._v(" "),a("th",[e._v("Description")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("0F 01 C8")]),e._v(" "),a("td",[e._v("MONITOR")]),e._v(" "),a("td",[e._v("Sets up a linear address range to be monitored by hardware and activates the monitor. The address range should be of a write-back memory caching type.")])])])]),e._v(" "),a("h2",{attrs:{id:"description"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#description"}},[e._v("#")]),e._v(" Description")]),e._v(" "),a("p",[e._v("The MONITOR instruction arms the address monitoring hardware using the address specified in EAX. The address range that the monitoring hardware will check for store operations can be determined by the CPUID instruction. The monitoring hardware will detect stores to an address within the address range and triggers the monitor hardware when the write is detected. The state of the monitor hardware is used by the MWAIT instruction.")]),e._v(" "),a("p",[e._v("The content of EAX is an effective address. By default, the DS segment is used to create a linear address that is then monitored. Segment overrides can be used with the MONITOR instruction.")]),e._v(" "),a("p",[e._v("ECX and EDX are used to communicate other information to the MONITOR instruction. ECX specifies optional extensions for the MONITOR instruction. EDX specifies optional hints for the MONITOR instruction and does not change the architectural behavior of the instruction. For the Pentium 4 processor with CPUID signature of family = 15 and model = 3, no extensions or hints are defined. Specifying undefined hints in EDX are ignored by the processor, whereas specifying undefined extensions in ECX will raise a general protection fault exception on the execution of the MONITOR instruction.")]),e._v(" "),a("p",[e._v("The address range must be in memory of write-back type. Only write-back memory type stores to the monitored address range will trigger the monitoring hardware. If the address range is not in memory of write-back type, the address monitor hardware may not be armed properly. The MONITOR instruction is ordered as a load operation with respect to other memory transactions.")]),e._v(" "),a("p",[e._v("Additional information for determining the address range to prevent false wake-ups is described in Chapter 7 of the IA-32 Intel Architecture Software Developer's Manual, Volume 3.")]),e._v(" "),a("p",[e._v("The MONITOR instruction can be used at all privilege levels and is subject to all permission checking and faults associated with a byte load. Like a load, the MONITOR instruction sets the A-bit but not the D-bit in the page tables. The MONITOR CPUID feature flag (bit 3 of ECX when CPUID is executed with EAX=1) indicates the availability of MONITOR and MWAIT instructions in the processor. When set, the unconditional execution of MONITOR is supported at privilege levels 0 and conditional execution at privilege levels 1 through 3 (software should test for the appropriate support of these instructions before unconditional use). The operating system or system BIOS may disable this instruction through the IA32_MISC_ENABLES MSR; disabling the instruction clears the CPUID feature flag and causes execution of the MONITOR instruction to generate an illegal opcode exception.")]),e._v(" "),a("h2",{attrs:{id:"operation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#operation"}},[e._v("#")]),e._v(" Operation")]),e._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/*\nMONITOR sets up an address range for the monitor hardware using the content of EAX as an\neffective address and puts the monitor hardware in armed state. The memory address range\nshould be within memory of the write-back caching type. A store to the specified address range\nwill trigger the monitor hardware. The content of ECX and EDX are used to communicate other\ninformation to the monitor hardware.\n*/")]),e._v("\n\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br")])]),a("h2",{attrs:{id:"protected-mode-exceptions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#protected-mode-exceptions"}},[e._v("#")]),e._v(" Protected Mode Exceptions")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[a("a",{attrs:{href:""}})]),e._v(" "),a("th")])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("#GP(0)")]),e._v(" "),a("td",[e._v("For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments.")])]),e._v(" "),a("tr",[a("td",[e._v("#GP(0)")]),e._v(" "),a("td",[e._v("For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments.")])]),e._v(" "),a("tr",[a("td",[e._v("#GP(0)")]),e._v(" "),a("td",[e._v("For ECX has a value other than 0.")])]),e._v(" "),a("tr",[a("td",[e._v("#SS(0)")]),e._v(" "),a("td",[e._v("For an illegal address in the SS segment.")])]),e._v(" "),a("tr",[a("td",[e._v("#PF(fault-code)")]),e._v(" "),a("td",[e._v("For a page fault (TBD).")])])])]),e._v(" "),a("h2",{attrs:{id:"real-address-mode-exceptions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#real-address-mode-exceptions"}},[e._v("#")]),e._v(" Real-Address Mode Exceptions")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[a("a",{attrs:{href:""}})]),e._v(" "),a("th")])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("#GP")]),e._v(" "),a("td",[e._v("If any part of the operand lies outside of the effective address space from 0 to FFFFH.")])]),e._v(" "),a("tr",[a("td",[e._v("#GP")]),e._v(" "),a("td",[e._v("If any part of the operand lies outside of the effective address space from 0 to FFFFH.")])]),e._v(" "),a("tr",[a("td",[e._v("#GP(0)")]),e._v(" "),a("td",[e._v("For ECX has a value other than 0.")])])])]),e._v(" "),a("h2",{attrs:{id:"virtual-8086-mode-exceptions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#virtual-8086-mode-exceptions"}},[e._v("#")]),e._v(" Virtual-8086 Mode Exceptions")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[a("a",{attrs:{href:""}})]),e._v(" "),a("th")])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("#GP")]),e._v(" "),a("td",[e._v("If any part of the operand lies outside of the effective address space from 0 to FFFFH.")])]),e._v(" "),a("tr",[a("td",[e._v("#GP")]),e._v(" "),a("td",[e._v("If any part of the operand lies outside of the effective address space from 0 to FFFFH.")])]),e._v(" "),a("tr",[a("td",[e._v("#GP(0)")]),e._v(" "),a("td",[e._v("For ECX has a value other than 0.")])]),e._v(" "),a("tr",[a("td",[e._v("#UD")]),e._v(" "),a("td",[e._v("If CPUID feature flag MONITOR is 0. If executed at privilege level 1 through 3 when the instruction is not available. If LOCK, REP, REPNE/NZ and Operand Size override prefixes are used.")])])])])])}),[],!1,null,null,null);t.default=s.exports}}]);